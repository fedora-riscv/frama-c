--- ./src/type/datatype.mli.orig	2011-10-10 02:38:09.000000000 -0600
+++ ./src/type/datatype.mli	2012-07-30 15:57:27.983244802 -0600
@@ -249,10 +249,27 @@ module type Map = sig
 
 end
 
+module type Hashtbl_S = sig
+    type key
+    type 'a t
+    val create : int -> 'a t
+    val clear : 'a t -> unit
+    val copy : 'a t -> 'a t
+    val add : 'a t -> key -> 'a -> unit
+    val remove : 'a t -> key -> unit
+    val find : 'a t -> key -> 'a
+    val find_all : 'a t -> key -> 'a list
+    val replace : 'a t -> key -> 'a -> unit
+    val mem : 'a t -> key -> bool
+    val iter : (key -> 'a -> unit) -> 'a t -> unit
+    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
+    val length : 'a t -> int
+end
+
 (** A standard OCaml hashtbl signature extended with datatype operations. *)
 module type Hashtbl = sig
 
-  include Hashtbl.S
+  include Hashtbl_S
 
   val memo: 'a t -> key -> (key -> 'a) -> 'a
   (** [memo tbl k f] returns the binding of [k] in [tbl]. If there is
@@ -468,7 +485,7 @@ module Set(S: Set.S)(E: S with type t =
 module Map(M: Map_common_interface.S)(Key: S with type t = M.key)(Info: Functor_info) :
   Map with type 'a t = 'a M.t and type key = M.key and module Key = Key
 
-module Hashtbl(H: Hashtbl.S)(Key: S with type t = H.key)(Info : Functor_info):
+module Hashtbl(H: Hashtbl_S)(Key: S with type t = H.key)(Info : Functor_info):
   Hashtbl with type 'a t = 'a H.t and type key = H.key and module Key = Key
 
 module type Sub_caml_weak_hashtbl = sig
--- ./src/type/datatype.ml.orig	2011-10-10 02:38:09.000000000 -0600
+++ ./src/type/datatype.ml	2012-07-30 16:02:06.952251779 -0600
@@ -306,8 +306,25 @@ module type Map = sig
   module Make(Data: S) : S with type t = Data.t t
 end
 
+module type Hashtbl_S = sig
+  type key
+  type 'a t
+  val create : int -> 'a t
+  val clear : 'a t -> unit
+  val copy : 'a t -> 'a t
+  val add : 'a t -> key -> 'a -> unit
+  val remove : 'a t -> key -> unit
+  val find : 'a t -> key -> 'a
+  val find_all : 'a t -> key -> 'a list
+  val replace : 'a t -> key -> 'a -> unit
+  val mem : 'a t -> key -> bool
+  val iter : (key -> 'a -> unit) -> 'a t -> unit
+  val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
+  val length : 'a t -> int
+end
+
 module type Hashtbl = sig
-  include Hashtbl.S
+  include Hashtbl_S
   val memo: 'a t -> key -> (key -> 'a) -> 'a
   module Key: S with type t = key
   module Make(Data: S) : S with type t = Data.t t
@@ -970,7 +987,7 @@ end
 module Initial_caml_hashtbl = Hashtbl
 
 (* ocaml functors are generative *)
-module Hashtbl(H: Hashtbl.S)(Key: S with type t = H.key)(Info : Functor_info) =
+module Hashtbl(H: Hashtbl_S)(Key: S with type t = H.key)(Info : Functor_info) =
 struct
 
   let () = check Key.equal "equal" Key.name Info.module_name
--- ./src/wp/fol_formula.ml.orig	2011-10-10 02:38:21.000000000 -0600
+++ ./src/wp/fol_formula.ml	2012-07-30 15:58:42.512246809 -0600
@@ -389,7 +389,7 @@ let iter_all section f =
 module type Identifiable =
 sig
   type t
-  module H : Hashtbl.S
+  module H : Datatype.Hashtbl_S
   val index : t -> H.key
   val prefix : string
   val basename : t -> string
--- ./src/wp/formula.mli.orig	2011-10-10 02:38:21.000000000 -0600
+++ ./src/wp/formula.mli	2012-07-30 15:59:14.902247733 -0600
@@ -147,7 +147,7 @@ sig
   module type Identifiable =
   sig
     type t
-    module H : Hashtbl.S
+    module H : Datatype.Hashtbl_S
     val index : t -> H.key
     val prefix : string
     val basename : t -> string
--- ./src/wp/LogicId.mli.orig	2011-10-10 02:38:21.000000000 -0600
+++ ./src/wp/LogicId.mli	2012-07-30 15:58:16.654245955 -0600
@@ -40,7 +40,7 @@ val dummy : id (** Only usable for repre
 
 module Iset : Set.S with type elt = t
 module Imap : Map.S with type key = t
-module Ihmap : Hashtbl.S with type key = t
+module Ihmap : Datatype.Hashtbl_S with type key = t
 
 (** {3 Name Spaces} *)
 
