--- a/configure	2021-12-07 08:29:43.768272605 -0700
+++ b/configure	2021-12-07 08:30:41.829292069 -0700
@@ -12137,9 +12137,9 @@ fi
 
 
     if test "$COQC" = "yes" ; then
-      COQVERSION=`coqc -v | sed -n -e 's|.*version* *\([^ ]*\) .*$|\1|p' `
+      COQVERSION=`coqc -v | sed -n -e 's|.*version* *\([^ ]*\).*|\1|p' `
       case $COQVERSION in
-        8.13.*|trunk)
+        8.13.*|8.14.*|trunk)
           { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: coqc version $COQVERSION found" >&5
 printf "%s\n" "coqc version $COQVERSION found" >&6; }
           ;;
--- a/src/plugins/wp/configure	2021-12-07 08:29:43.770272606 -0700
+++ b/src/plugins/wp/configure	2021-12-07 08:31:09.509301340 -0700
@@ -2396,9 +2396,9 @@ fi
 
 
     if test "$COQC" = "yes" ; then
-      COQVERSION=`coqc -v | sed -n -e 's|.*version* *\([^ ]*\) .*$|\1|p' `
+      COQVERSION=`coqc -v | sed -n -e 's|.*version* *\([^ ]*\).*|\1|p' `
       case $COQVERSION in
-        8.13.*|trunk)
+        8.13.*|8.14.*|trunk)
           { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: coqc version $COQVERSION found" >&5
 printf "%s\n" "coqc version $COQVERSION found" >&6; }
           ;;
--- a/src/plugins/wp/share/coqwp/Bits.v	2021-11-29 17:00:00.000000000 -0700
+++ b/src/plugins/wp/share/coqwp/Bits.v	2021-12-07 08:29:43.770272606 -0700
@@ -57,6 +57,7 @@ Definition Zfc := nat -> bool.
 Require Import ZArith.
 Require Import FunctionalExtensionality.
 Require Import Qedlib.
+Require Import Lia.
 
 Close Scope Z_scope.
 
@@ -74,7 +75,7 @@ Ltac case_eqb H e :=
 
 (** Find arithmetic contradiction. *)
 Ltac arithContradiction :=
-  cut False; [contradiction; try omega|];auto with arith.
+  cut False; [contradiction; try lia|];auto with arith.
 
 (** Cases [Inf:i<j], [EQ:i=j] and [Sup:i>j]. *)
 Ltac nat_compare Inf EQ Sup i j :=
@@ -138,14 +139,14 @@ Proof.
   pose (K:=(two_power_nat (m - n))); fold K; intro.  
   generalize (two_power_nat_is_positive n); intro.
   rewrite <- (Z.mul_1_r (two_power_nat n)) at 1.
-  apply Zmult_le_compat_l; omega.
+  apply Zmult_le_compat_l; lia.
 Qed.
 						    
 Remark two_power_nat_increase_strict: forall n m,
   n < m -> (two_power_nat n < two_power_nat m)%Z.
 Proof.
   intros.
-  rewrite (le_plus_minus (n+1) m) by omega.
+  rewrite (le_plus_minus (n+1) m) by lia.
   rewrite two_power_nat_plus.
   generalize (two_power_nat_is_positive (m - (n+1))).
   pose (K:=(two_power_nat (m - (n+1)))); fold K; intro.  
@@ -155,7 +156,7 @@ Proof.
   rewrite <- (Z.mul_1_r (two_power_nat n)) at 1.
   replace (two_power_nat n * 2 * K)%Z with (two_power_nat n * (2 * K))%Z
     by ring.
-  apply Zmult_gt_0_lt_compat_l; omega.
+  apply Zmult_gt_0_lt_compat_l; lia.
 Qed.
 						    
 (** {@trailing:} *)
@@ -243,12 +244,12 @@ Proof.
   generalize (last_null_or_flip f m b).
   intros [ Last_null | Last_flip ].
   (** Last is Null *)
-  + fold j in Last_null. rewrite Last_null in Leq. omega.
+  + fold j in Last_null. rewrite Last_null in Leq. lia.
   (** Last if a flip *)
   + destruct Last_flip as [ k [ kj flip ] ].
     fold j in kj. 
     absurd (f k = b); auto.
-    apply Range; omega.
+    apply Range; lia.
 Qed.
 
 (** {@positive:} *)
@@ -272,7 +273,7 @@ Fixpoint xHpos (p:positive): nat :=
 Remark xHpos_incr : 
   forall p a: positive, xHpos p <= xHpos (p + a).
 Proof.
- induction p; intros; simpl; case a; intros; simpl; try omega;
+ induction p; intros; simpl; case a; intros; simpl; try lia;
  apply le_n_S;
  try rewrite Pplus_one_succ_r;
  try (rewrite Pplus_carry_spec; rewrite Pplus_one_succ_r;rewrite<- Pplus_assoc);
@@ -344,7 +345,7 @@ Proof.
   induction n; intros i j; simpl; auto.
   unfold P_shift at 1.
   case_eqb BIT (f (i+j)); f_equal; 
-    (replace (S(i+j)) with (i + S j) by omega);
+    (replace (S(i+j)) with (i + S j) by lia);
     apply IHn.
 Qed.
 
@@ -364,7 +365,7 @@ Remark NEXT_I: forall (n: nat) (p: posit
   P_recomp n (P_decomp p~1) 1 = P_recomp n (P_decomp p) 0.
 Proof.
   intros.
-  replace 1 with (1+0) by omega.
+  replace 1 with (1+0) by lia.
   rewrite P_recomp_shift.
   rewrite P_decomp_shift1.
   auto.
@@ -375,7 +376,7 @@ Remark NEXT_O: forall (n: nat) (p: posit
   P_recomp n (P_decomp p~0) 1 = P_recomp n (P_decomp p) 0.
 Proof.
   intros.
-  replace 1 with (1+0) by omega.
+  replace 1 with (1+0) by lia.
   rewrite P_recomp_shift.
   rewrite P_decomp_shift0.
   auto.
@@ -400,13 +401,13 @@ Lemma P_decomp_recomp: forall (f: Zfc) (
   k < n -> P_decomp (P_recomp n f i) k = f (i+k).
 Proof.
   intros f n.
-  induction n. intros. apply False_ind. omega.
+  induction n. intros. apply False_ind. lia.
   intros i k Limit.
   simpl. destruct k.
-  case_eqb Fi (f i); simpl; rewrite <- Fi; f_equal; omega.
+  case_eqb Fi (f i); simpl; rewrite <- Fi; f_equal; lia.
   destruct (f i); simpl.
-  rewrite IHn. f_equal. omega. omega.
-  rewrite IHn. f_equal. omega. omega.
+  rewrite IHn. f_equal. lia. lia.
+  rewrite IHn. f_equal. lia. lia.
 Qed.
 
 (** Last bits of positive. *)
@@ -441,7 +442,7 @@ Definition NxHpos (n:N): nat :=
 Remark NxHpos_incr: forall x a: N, NxHpos x <= NxHpos (x + a).
 Proof.
   destruct x; destruct a; simpl; try (by compute).
-  cut (xHpos p <= xHpos (p + p0)). omega.
+  cut (xHpos p <= xHpos (p + p0)). lia.
   apply xHpos_incr.
 Qed.
 
@@ -514,9 +515,9 @@ Proof.
   intros n f Trail.
   unfold N_recomp.
   destruct (last_null_or_flip f n false) as [ZERO | FLIP].
-  rewrite ZERO. intros. apply False_ind. omega.
+  rewrite ZERO. intros. apply False_ind. lia.
   destruct (last f n false) eqn:LAST. 
-  intros. apply False_ind. omega.
+  intros. apply False_ind. lia.
   intro ONE.
   assert (XH: P_recomp n0 f 0 = xH). inversion ONE; trivial.
   destruct FLIP as [ K1 [ SKN B1not ] ].
@@ -543,7 +544,7 @@ Proof.
   intros [ ZERO | FLIP ].
   (** ZERO *)
   + rewrite ZERO. simpl. extensionality k. symmetry.
-    cut (trailing f 0 false). intro H. apply H. omega.
+    cut (trailing f 0 false). intro H. apply H. lia.
     rewrite <- ZERO.
     apply trailing_last. auto.
   (** FLIP *)
@@ -568,7 +569,7 @@ Proof.
       fold x.
       intro xHk.
       rewrite (P_decomp_limit x i); [|rewrite xHk;auto].
-      cut (trailing f (S k) false). intro H. symmetry. apply H. omega.
+      cut (trailing f (S k) false). intro H. symmetry. apply H. lia.
       rewrite <- Last. apply trailing_last. auto.
 Qed.
 
@@ -620,25 +621,25 @@ Qed.
 Remark zlnot_inj: forall x y : Z,
   (zlnot x) = (zlnot y) -> x = y.
 Proof.
-  unfold zlnot. intros. omega. 
+  unfold zlnot. intros. lia. 
 Qed.
 Remark zlnot_sym: forall x y : Z,
   (zlnot x) = y -> x = (zlnot y).
 Proof.
-  unfold zlnot. intros. omega. 
+  unfold zlnot. intros. lia. 
 Qed.
 
 Lemma P_zlnot_sym: forall P (b: Z),
   0 <= b -> ((forall z: Z, -b <= z -> P z) -> (forall z:Z, z < b -> P (zlnot z))).
 Proof.
-  intros P b Bge0 Hyp z H. assert (-b <= zlnot z). unfold zlnot. omega.
+  intros P b Bge0 Hyp z H. assert (-b <= zlnot z). unfold zlnot. lia.
   apply Hyp. auto.
 Qed.
 
 Lemma P_zlnot_sym_rev: forall P (b: Z),
   0 <= b -> ((forall z:Z, z < b -> P z) -> (forall z:Z, -b <= z -> P (zlnot z))).
 Proof.
-  intros P b Bge0 Hyp z H. assert (zlnot z < b). unfold zlnot. omega.
+  intros P b Bge0 Hyp z H. assert (zlnot z < b). unfold zlnot. lia.
   apply Hyp. auto.
 Qed.
 
@@ -847,7 +848,7 @@ Proof.
       pose (u := Zneg p). fold u.
       pose (v := Zpos p). fold v.
       replace u with (-v) by (unfold u; unfold v; simpl; trivial).
-      omega.
+      lia.
     (** cont. *)
     * assert  (Q : z = 0 \/ exists q, z = Zpos q).
       { destruct p. 
@@ -879,7 +880,7 @@ Proof.
     case_leq 0 (zlnot x); intro SIGN; simpl.
     (** 0 <= zlnot x -> contradiction *) 
     * unfold zlnot in SIGN.
-      apply False_ind. omega.
+      apply False_ind. lia.
     (** 0 > zlnot x *)
     * apply fnot_inj. rewrite fnot_inv. fold f. unfold x.
       apply N_decomp_recomp. 
@@ -890,7 +891,7 @@ Proof.
   + pose ( f := btest b ). fold f.
     pose ( x := N_recomp (bsize b) f ). fold x.
     assert ( Xpos : 0 <= x ) by ( apply N_recomp_pos; auto with zarith ).
-    case_leq 0 x; intro H; try (apply False_ind; omega; fail).
+    case_leq 0 x; intro H; try (apply False_ind; lia; fail).
     simpl. unfold f. unfold x. 
     apply N_decomp_recomp. 
     rewrite <- BSIGN. apply (btrail b).
@@ -907,7 +908,7 @@ Proof.
   + pose ( f := fnot (btest b)). fold f.
     pose ( x := N_recomp (bsize b) f ). fold x.
     assert ( Xpos : 0 <= x ) by ( apply N_recomp_pos; auto with zarith ).
-    case_leq 0 x; intro H; try (apply False_ind; omega; fail).
+    case_leq 0 x; intro H; try (apply False_ind; lia; fail).
     simpl. unfold f. unfold x. 
     apply N_decomp_recomp. 
     apply trailing_fnot. 
@@ -923,7 +924,7 @@ Proof.
     case_leq 0 (zlnot x); intro SIGN; simpl.
     (** 0 <= zlnot x -> contradiction *) 
     * unfold zlnot in SIGN.
-      apply False_ind. omega.
+      apply False_ind. lia.
     (** 0 > zlnot x *)
     * unfold f. f_equal.
       apply N_decomp_recomp. 
@@ -975,14 +976,14 @@ Proof.
     case_leq 0 (zlnot x); intro SIGN; simpl.
     (** 0 <= zlnot x -> contradiction *) 
     * unfold zlnot in SIGN.
-      apply False_ind. omega.
+      apply False_ind. lia.
     (** 0 > zlnot x *)
     * auto.
   (** POSITIVE SIGN *)
   + pose ( f := btest b ). fold f.
     pose ( x := N_recomp (bsize b) f ). fold x.
     assert ( Xpos : 0 <= x ) by ( apply N_recomp_pos; auto with zarith ).
-    case_leq 0 x; intro H; try (apply False_ind; omega; fail).
+    case_leq 0 x; intro H; try (apply False_ind; lia; fail).
     simpl. auto.
 Qed.
  
@@ -1072,7 +1073,7 @@ Proof.
     assert ( Xpos : 0 <= x ) by (apply N_recomp_pos; auto with zarith ).
     case_leq 0 (zlnot x); 
       intro H; 
-      try (unfold zlnot in H; apply False_ind; omega; fail).
+      try (unfold zlnot in H; apply False_ind; lia; fail).
     rewrite zlnot_inv.
     unfold x. unfold f. 
     rewrite NxHpos_N_recomp_pos. 
@@ -1083,7 +1084,7 @@ Proof.
   + case_leq 0 (N_recomp (bsize b) (btest b)); intro N_recomp.
     rewrite NxHpos_N_recomp_pos. trivial.
     generalize  (N_recomp_pos(bsize b) (btest b)).
-    intros.  apply False_ind. omega.
+    intros.  apply False_ind. lia.
 Qed.
 
 (** Two's complement symmetry *)
@@ -1114,7 +1115,7 @@ Proof.
         by rewrite IHn.
       by compute.
   (** 0 > two_power_nat n *)
-  + generalize (two_power_nat_is_positive n). omega.
+  + generalize (two_power_nat_is_positive n). lia.
 Qed.
  
 (** Position of the highest significant bit of the predecessor of [two_power_nat]. *)
@@ -1132,15 +1133,15 @@ Proof.
       rewrite two_power_nat_S in H.
       assert ((Nabs (2 * two_power_nat n - 1) = 2 * Nabs (two_power_nat n - 1) +1)%N) as EQ.
       { generalize (two_power_nat_is_positive n); intro.
-        assert (0 <= (two_power_nat n - 1)) as A0 by omega.
-        assert (0 < 2 * (two_power_nat n - 1) + 1) as A1 by omega.
-        replace (2 * two_power_nat n - 1) with (2 * (two_power_nat n - 1) + 1) by omega.
+        assert (0 <= (two_power_nat n - 1)) as A0 by lia.
+        assert (0 < 2 * (two_power_nat n - 1) + 1) as A1 by lia.
+        replace (2 * two_power_nat n - 1) with (2 * (two_power_nat n - 1) + 1) by lia.
         destruct (two_power_nat n - 1); by auto. }
       rewrite EQ.
       rewrite NxHpos_2x_p1.
       by rewrite IHn.
   (** 0 > two_power_nat n *)
-  + generalize (two_power_nat_is_positive n). omega.
+  + generalize (two_power_nat_is_positive n). lia.
 Qed.
  
 (** [ZxHpos] increases for positive input values *)  
@@ -1162,13 +1163,13 @@ Proof.
   intros.
   unfold ZxHpos. unfold zlnot.
   case_leq 0 x; case_leq 0 (x + a); 
-    intros; try (replace x with 0 by omega); try (by compute).
+    intros; try (replace x with 0 by lia); try (by compute).
   case_leq (-1) x; 
-    intros; try (replace x with (-1) by omega); try (by compute).
-  assert (- (x + 1) >= 0) as X by omega.
-  assert (- a >= 0) as A by omega.
+    intros; try (replace x with (-1) by lia); try (by compute).
+  assert (- (x + 1) >= 0) as X by lia.
+  assert (- a >= 0) as A by lia.
   clear H; clear H0; clear H1; clear H2; clear H3. 
-  replace (-(x+a+1)) with (-(x+1) + -a) by omega.
+  replace (-(x+a+1)) with (-(x+1) + -a) by lia.
   pose (b := -a); fold b; fold b in A.
   pose (y := -(x+1)); fold y; fold y in X.
   destruct y; destruct b; try (by compute).
@@ -1192,18 +1193,18 @@ Proof.
     * simpl. simpl in IHp.
       replace (Zpos p~1) with (2*(Zpos p) + 1)%Z by (auto with zarith).
       rewrite two_power_nat_S.
-      omega.
+      lia.
     (** 2p *)
     * simpl. simpl in IHp.
       replace (Zpos p~0) with (2*Zpos p)%Z by (auto with zarith).
       rewrite two_power_nat_S.
-      omega.
+      lia.
     (** one *)
     * by compute.
   (** negative *)
   + assert (Zneg p  < 0)%Z by (by simpl).
     generalize (two_power_nat_is_positive (ZxHpos (Zneg p))).
-    omega.
+    lia.
 Qed.
 
 (** Lower upper [two_power_nat] bound of an integer. *)
@@ -1223,12 +1224,12 @@ Proof.
   intro. unfold ZxHbound.
   case_leq 0 z; intro.
   (** 0 <= z *)
-  + generalize (two_power_nat_of_ZxHpos z). split; omega.
+  + generalize (two_power_nat_of_ZxHpos z). split; lia.
   (** 0 > z *)
   + generalize (two_power_nat_of_ZxHpos (-(z+1))).
     rewrite <- (ZxHpos_sym z).
     unfold zlnot.
-    split; omega.
+    split; lia.
 Qed.
 
 Remark ZxHpos_le: forall x y: Z,
@@ -1243,19 +1244,19 @@ Proof.
   (** base *)
   + generalize (two_power_nat_is_positive Y0).
     replace (two_power_nat 0) with 1 by (compute ; forward).
-    omega.
+    lia.
   (** cont. *)
   + rewrite two_power_nat_S. 
     induction Y0.
     (** base *)
     * generalize (two_power_nat_is_positive X0).
       replace (two_power_nat 0) with 1 by (compute ; forward).
-      omega.
+      lia.
     (** cont. *)
     * rewrite two_power_nat_S. 
-      cut ((2 * two_power_nat X0) <= (2 * two_power_nat Y0) -> (S X0 <= S Y0)%nat). omega.
+      cut ((2 * two_power_nat X0) <= (2 * two_power_nat Y0) -> (S X0 <= S Y0)%nat). lia.
       generalize (IHX0 Y0).
-      omega.
+      lia.
 Qed.
 
 Remark ZxHbound_le: forall x y: Z,
@@ -1271,20 +1272,20 @@ Proof.
   (** base *)
   + generalize (two_power_nat_is_positive Y0).
     replace (two_power_nat 0) with 1 by (compute ; forward).
-    omega.
+    lia.
   (** cont. *)
   + rewrite two_power_nat_S. 
     induction Y0.
     (** base *)
     * generalize (two_power_nat_is_positive X0).
       replace (two_power_nat 0) with 1 by (compute ; forward).
-      omega.
+      lia.
     (** cont. *)
     * intro.
       rewrite two_power_nat_S. 
-      cut ((2 * two_power_nat X0) <= (2 * two_power_nat Y0)). omega.
+      cut ((2 * two_power_nat X0) <= (2 * two_power_nat Y0)). lia.
       apply (IHX0 Y0).
-      omega.
+      lia.
 Qed.
 
 Remark ZxHbound_lt: forall x y: Z,
@@ -1300,19 +1301,19 @@ Proof.
   (** base *)
   + generalize (two_power_nat_is_positive Y0).
     replace (two_power_nat 0) with 1 by (compute ; forward).
-    induction Y0; repeat rewrite two_power_nat_S; omega.
+    induction Y0; repeat rewrite two_power_nat_S; lia.
   (** cont. *)
   + rewrite two_power_nat_S. 
     induction Y0.
     (** base *)
     * generalize (two_power_nat_is_positive X0).
       replace (two_power_nat 0) with 1 by (compute;forward).
-      omega.
+      lia.
     (** cont. *)
     * intro.
       rewrite two_power_nat_S. 
       apply (IHX0 Y0).
-      omega.
+      lia.
 Qed.
 
 Lemma ZxHpower: forall (n: nat) (z: Z),
@@ -1327,7 +1328,7 @@ Proof.
   + clear H.
     replace (two_power_nat n - 1) with (z + ((two_power_nat n - 1) - z)) by auto with zarith.
     pose (d := ((two_power_nat n - 1) - z)); fold d.
-    assert (0 <= d) as D by (unfold d; omega).
+    assert (0 <= d) as D by (unfold d; lia).
     by (apply ZxHpos_incr_for_positive).
   (** 0 > z *)
   + rewrite <- (ZxHpos_sym z).
@@ -1335,9 +1336,9 @@ Proof.
     replace (two_power_nat n - 1) with (-(z+1) + (z+two_power_nat n)) by auto with zarith.
     pose (x := -(z+1)); fold x.
     pose (d := (z + two_power_nat n)); fold d.
-    assert (0 <= d) as D by (unfold d; omega).
+    assert (0 <= d) as D by (unfold d; lia).
     apply ZxHpos_incr_for_positive.
-    unfold x. omega. unfold d. omega.
+    unfold x. lia. unfold d. lia.
 Qed.
 
 (** ** Main tactics.*)
--- a/src/plugins/wp/share/coqwp/Cbits.v	2021-11-29 17:00:00.000000000 -0700
+++ b/src/plugins/wp/share/coqwp/Cbits.v	2021-12-07 08:29:43.771272606 -0700
@@ -35,6 +35,7 @@ Require real.Real.
 Require real.RealInfix.
 Require real.FromInt.
 Require Cint.
+Require Import Lia.
 
 (* Why3 goal *)
 Lemma lnot_bool : ((Cint.lnot 0%Z) = (-1%Z)%Z) /\
@@ -327,7 +328,7 @@ Defined.
 
 (** * Bit extraction *)
 (** Tacticals *)
-Local Ltac omegaContradiction := cut False; [contradiction|omega].
+Local Ltac liaContradiction := cut False; [contradiction|lia].
 
 Ltac unfold_bit_testb h := 
   unfold bit_testb; unfold Zbits.bit_testb; 
@@ -340,11 +341,11 @@ Proof.
   intros.
   split; case_lt x y; intros; try rewrite H0.
   + split; intro G; auto.
-  + split; intro G; [discriminate G| omega].
+  + split; intro G; [discriminate G| lia].
   + auto.
   + destruct b; try auto.
     destruct H0. assert (x < y) by (by (apply H0)).
-    omegaContradiction.
+    liaContradiction.
 Qed.
 
 (** ** Definition of bit_test predicate *)
@@ -420,7 +421,7 @@ Proof.
   rewrite <- lsl_1_0.
   intro.
   apply bit_test_extraction.
-  + omega.
+  + lia.
   + rewrite Zbits.land_commut.
     auto.
 Qed.
@@ -555,7 +556,7 @@ Proof.
   unfold Zbits.lsl_arithmetic_def.
   rewrite Zabs2Nat.abs_nat_nonneg by auto.
   rewrite Zabs2Nat.abs_nat_nonneg by auto.
-  rewrite Z2Nat.inj_add by omega.
+  rewrite Z2Nat.inj_add by lia.
   pose (n0:=Z.to_nat n); fold n0.
 
   replace ((Z.to_nat 1%Z)%nat) with (1%nat) by auto.
@@ -568,7 +569,7 @@ Proof.
   cut((land 1 x < 2)%Z) ; auto with zarith.
 
   case_eq ((land 1 x)%Z) (0%Z); intros.
-  rewrite bit_test_extraction_bis_eq; [omega|].
+  rewrite bit_test_extraction_bis_eq; [lia|].
   apply bit_test_extraction_bis. 
   auto. 
 Qed.
@@ -583,7 +584,7 @@ Proof.
   unfold lsl. unfold Zbits.lsl. 
   unfold_bit_testb h1.
   rewrite (Zle_imp_le_bool _ _ h2).
-  rewrite (Zle_imp_le_bool 0 (m - n)) by omega.
+  rewrite (Zle_imp_le_bool 0 (m - n)) by lia.
   rewrite Zbits.lsl_extraction.
   rewrite (Z.abs_eq n); auto.
   rewrite (Z.abs_eq m); auto.
@@ -614,8 +615,6 @@ Proof.
   rewrite (Z.abs_eq n); auto.
   rewrite (Z.abs_eq m); auto.
   case_leq n m.
-  intros.
-  reflexivity.
 Qed.
 
 (* Why3 goal *)
@@ -710,10 +709,10 @@ Proof.
   rewrite Zbits.bit_testb_pos ; auto.
   + assert (HB:(Bits.Zbit x (Z.abs_nat j) = false)).
     {(apply (Zbits.Zbit_unsigned_trail  (Z.abs_nat i) (Z.abs_nat j) x); auto).
-      apply Zabs_nat_le; omega. }     
+      apply Zabs_nat_le; lia. }     
     unfold Zbits.zbit_test_def.
     rewrite HB; discriminate.
-  + omega.
+  + lia.
 Qed.
 
 (* Why3 goal *)
@@ -757,10 +756,10 @@ Proof.
   assert (H:(Bits.Zbit x (Z.abs_nat i) = false)).
   { unfold Cint.is_uint in h2.
     apply (Zbits.Zbit_unsigned_trail (Z.abs_nat n) (Z.abs_nat i) x).
-    + apply Zabs_nat_le. omega.
+    + apply Zabs_nat_le. lia.
     + unfold Cint.two_power_abs in h2.
       trivial. }
-  assert (I:(0 <= i)) by omega;
+  assert (I:(0 <= i)) by lia;
   unfold bit_test; unfold_bit_testb I; unfold Zbits.zbit_test_def.
   rewrite H; discriminate.
 Qed.
@@ -779,7 +778,7 @@ Proof.
   rewrite Zbits.Zbit_uint_mod_two_power_nat.
   rewrite (leb_correct_conv k (Z.abs_nat n)).
   + trivial.
-  + apply Zabs_nat_lt; omega.
+  + apply Zabs_nat_lt; lia.
 Qed.
 
 (* Why3 goal *)
@@ -806,11 +805,11 @@ Proof.
   assert (forall i: int, (0 <= i)%Z -> (bit_test x i <-> bit_test y i)).
   { intros.
     case_lt i n; intro.
-    + apply h4; omega.
+    + apply h4; lia.
     + assert (~ bit_test x i).
-      { apply (to_uint_extraction_sup n). omega. auto. }
+      { apply (to_uint_extraction_sup n). lia. auto. }
       assert (~ bit_test y i).
-      { apply (to_uint_extraction_sup n). omega. auto. }
+      { apply (to_uint_extraction_sup n). lia. auto. }
      intuition. }
   clear h1; clear h2; clear h3; clear h4.
   unfold bit_test in H.
@@ -823,12 +822,12 @@ Qed.
 Local Ltac uint_extraction_inf_bool to_uint :=
   intros; rewrite to_uint; 
   apply to_uint_extraction_inf_bool;
-  omega.
+  lia.
   
 Local Ltac uint_extraction_inf to_uint :=
   intros; rewrite to_uint; 
   apply to_uint_extraction_inf;
-  omega.
+  lia.
 						 
 (** *** Cast to uint8 C type *)
 (* Why3 goal *)
@@ -979,10 +978,10 @@ Proof.
   intros n x i h1.
   unfold Cint.is_sint.
   intro h2;
-  assert (H:(0 <= i)) by omega;
+  assert (H:(0 <= i)) by lia;
   unfold bit_test; unfold_bit_testb H; unfold Zbits.zbit_test_def.
   assert (Z.abs_nat n <= Z.abs_nat i)%nat.
-  { apply (Zabs_nat_le); omega. }
+  { apply (Zabs_nat_le); lia. }
   rewrite <- Zlt_bool_true_Zlt; 
   apply (Zbits.Zbit_trail (Z.abs_nat n) (Z.abs_nat i) x); auto.
 Qed.
@@ -1000,7 +999,7 @@ Proof.
   replace (Cint.two_power_abs n + Cint.two_power_abs n) with (2 * Cint.two_power_abs n) by (auto with zarith).
   unfold Cint.two_power_abs.
   replace n with ((n-i)+i) by (auto with zarith).
-  rewrite Zabs2Nat.inj_add by omega.
+  rewrite Zabs2Nat.inj_add by lia.
   apply Zbits.Zbit_sint_mod_two_power_nat.
 Qed.
 
@@ -1028,17 +1027,17 @@ Proof.
   assert (forall i: int, (0 <= i)%Z -> (bit_test x i <-> bit_test y i)).
   { intros.
     case_leq i n; intro.
-    + apply h4; omega.
-    + assert (0<=n<=n) by omega.
+    + apply h4; lia.
+    + assert (0<=n<=n) by lia.
       specialize ((h4 n) H1).
       generalize ((to_sint_extraction_sup n x n) H1 h2).
       generalize ((to_sint_extraction_sup n y n) H1 h3).
       clear H1; intros.
       rewrite h4 in H2. rewrite H2 in H1. clear H2.
       assert ((bit_test x i) <-> x < 0).
-      { apply (to_sint_extraction_sup n); [omega | auto]. }
+      { apply (to_sint_extraction_sup n); [lia | auto]. }
       assert ((bit_test y i) <-> y < 0).
-      { apply (to_sint_extraction_sup n); [omega | auto]. }
+      { apply (to_sint_extraction_sup n); [lia | auto]. }
       rewrite H2.
       rewrite H3.
       auto. }
@@ -1055,11 +1054,11 @@ Local Ltac sint_extraction_sup is_sint v
   intros x i h1;
   unfold is_sint;
   intro h2;
-  assert (H:(0 <= i)) by omega;
+  assert (H:(0 <= i)) by lia;
   unfold bit_test; unfold_bit_testb H; unfold Zbits.zbit_test_def;
   assert (Z.abs_nat vz <= Z.abs_nat i)%nat 
   by (assert (vn = Z.abs_nat vz)%nat by (auto with arith);
-      apply Zabs_nat_le; omega);
+      apply Zabs_nat_le; lia);
   rewrite <- Zlt_bool_true_Zlt; 
   apply (Zbits.Zbit_trail vn (Z.abs_nat i) x); auto.
 
@@ -1076,12 +1075,12 @@ Local Ltac unfold_hyp h :=
 Local Ltac sint_extraction_inf_bool to_sint :=
   intros; rewrite to_sint; 
   apply to_sint_extraction_inf_bool;
-  omega.
+  lia.
   
 Local Ltac sint_extraction_inf to_sint :=
   intros; rewrite to_sint; 
   apply to_sint_extraction_inf;
-  omega.
+  lia.
 						 
 (** *** Cast to sint8 C type *)
 (* Why3 goal *)
@@ -1232,8 +1231,8 @@ Local Ltac is_uint_bitwise f n :=
 Local Ltac lsr_in_uint_range n :=
   intros x y Ry Rx; unfold_hyp Rx; apply Cint.id_to_range;
   split;
-  [ (apply (Zbits.lsr_lower_bound 0 _ _ Ry); omega)
-  | (apply (Zbits.lsr_upper_bound n _ _ Ry); omega)].
+  [ (apply (Zbits.lsr_lower_bound 0 _ _ Ry); lia)
+  | (apply (Zbits.lsr_upper_bound n _ _ Ry); lia)].
 
 (** ** Unsigned conversions *)
   
@@ -1329,7 +1328,7 @@ Lemma is_uint_lsl1_inf :
   ((Cint.to_uint n (lsl 1%Z y)) = (lsl 1%Z y)).
 Proof.
   intros n y (h1,h2);
-  (assert (0 <= y) as Ry by omega);
+  (assert (0 <= y) as Ry by lia);
   unfold lsl; unfold Zbits.lsl; rewrite (Zle_imp_le_bool _ _ Ry);
   unfold Zbits.lsl_def;
   rewrite Zbits.lsl_arithmetic_shift; unfold Zbits.lsl_arithmetic_def.
@@ -1338,7 +1337,7 @@ Proof.
   clear Ry.
 
   assert (Z.abs_nat y < (Z.abs_nat n))%nat as A by
-   (apply Zabs_nat_lt; omega);
+   (apply Zabs_nat_lt; lia);
   clear h1; clear h2;
   pose (M := Z.abs_nat y); fold M; fold M in A.
 
@@ -1347,7 +1346,7 @@ Proof.
   unfold Cint.two_power_abs; pose (N:=(Z.abs_nat n)); fold N; fold N in A.
   generalize (Bits.two_power_nat_is_positive M); intro Pos.
   generalize (Bits.two_power_nat_increase_strict M N A) ; intro.
-  omega.
+  lia.
 Qed.
 
 (* Why3 goal *)
@@ -1356,7 +1355,7 @@ Lemma is_uint_lsl1_sup :
   ((Cint.to_uint n (lsl 1%Z y)) = 0%Z).
 Proof.
   intros n y h1.
-  (assert (0 <= y) as Ry by omega);
+  (assert (0 <= y) as Ry by lia);
   unfold lsl; unfold Zbits.lsl; rewrite (Zle_imp_le_bool _ _ Ry);
   unfold Zbits.lsl_def;
   rewrite Zbits.lsl_arithmetic_shift; unfold Zbits.lsl_arithmetic_def.
@@ -1365,7 +1364,7 @@ Proof.
   clear Ry.
 
   assert (Z.abs_nat n <= (Z.abs_nat y))%nat as A by
-   (apply Zabs_nat_le; omega);
+   (apply Zabs_nat_le; lia);
   clear h1;
   pose (M := Z.abs_nat y); fold M; fold M in A.
   unfold Cint.to_uint; unfold Cint.to_range; Cint.simplify_to_range_unfolding.
@@ -1422,7 +1421,7 @@ Qed.
 Lemma is_uint8_lsl1_sup :
   forall (y:Z), (8%Z <= y)%Z -> ((Cint.to_uint8 (lsl 1%Z y)) = 0%Z).
 Proof.
-  intros; rewrite Cint.to_uint_8; apply is_uint_lsl1_sup; omega.
+  intros; rewrite Cint.to_uint_8; apply is_uint_lsl1_sup; lia.
 Qed.
 
 (** ***  Cast to uint16 C type *)
@@ -1470,7 +1469,7 @@ Qed.
 Lemma is_uint16_lsl1_sup :
   forall (y:Z), (16%Z <= y)%Z -> ((Cint.to_uint16 (lsl 1%Z y)) = 0%Z).
 Proof.
-  intros; rewrite Cint.to_uint_16; apply is_uint_lsl1_sup; omega.
+  intros; rewrite Cint.to_uint_16; apply is_uint_lsl1_sup; lia.
 Qed.
 
 (** *** Cast to uint32 C type *)
@@ -1518,7 +1517,7 @@ Qed.
 Lemma is_uint32_lsl1_sup :
   forall (y:Z), (32%Z <= y)%Z -> ((Cint.to_uint32 (lsl 1%Z y)) = 0%Z).
 Proof.
-  intros; rewrite Cint.to_uint_32; apply is_uint_lsl1_sup; omega.
+  intros; rewrite Cint.to_uint_32; apply is_uint_lsl1_sup; lia.
 Qed.
 
 (** *** Cast to uint64 C type *)
@@ -1566,14 +1565,14 @@ Qed.
 Lemma is_uint64_lsl1_sup :
   forall (y:Z), (64%Z <= y)%Z -> ((Cint.to_uint64 (lsl 1%Z y)) = 0%Z).
 Proof. 
-  intros; rewrite Cint.to_uint_64; apply is_uint_lsl1_sup; omega.
+  intros; rewrite Cint.to_uint_64; apply is_uint_lsl1_sup; lia.
 Qed.
 
 (** ** Signed conversions *)
 (** Tacticals *)
 Local Ltac is_sint_lnot b :=
   intros x Rx; unfold_hyp Rx; apply Cint.id_to_range;
-   apply (Zbits.lnot_in_range (-b) b x Rx); omega.
+   apply (Zbits.lnot_in_range (-b) b x Rx); lia.
 
 Local Ltac is_sint_bitwise f n :=
   intros x y Rx Ry; unfold_hyp Rx; unfold_hyp Ry; apply Cint.id_to_range;
@@ -1582,8 +1581,8 @@ Local Ltac is_sint_bitwise f n :=
 Local Ltac lsr_in_sint_range n :=
   intros x y Ry Rx; unfold_hyp Rx; apply Cint.id_to_range;
   split;
-  [ (apply (Zbits.lsr_lower_bound (-n) _ _ Ry); omega)
-  | (apply (Zbits.lsr_upper_bound n _ _ Ry); omega)].
+  [ (apply (Zbits.lsr_lower_bound (-n) _ _ Ry); lia)
+  | (apply (Zbits.lsr_upper_bound n _ _ Ry); lia)].
 
 (* Why3 goal *)
 Lemma is_sint_lnot :
@@ -1641,9 +1640,9 @@ Proof.
   generalize (Cint.two_power_abs_is_positive y);
   generalize (Cint.two_power_abs_is_positive n);
   unfold Cint.two_power_abs; intros.
-  split; [omega|].
+  split; [lia|].
   apply Bits.two_power_nat_increase_strict.
-  apply Zabs_nat_lt; omega.
+  apply Zabs_nat_lt; lia.
 Qed.
 
 (* Why3 goal *)
@@ -1652,7 +1651,7 @@ Lemma is_sint_lsl1_sup :
   ((Cint.to_sint n (lsl 1%Z y)) = 0%Z).
 Proof.
   intros n y h1.
-  assert (0 <= y) as Ry by omega;
+  assert (0 <= y) as Ry by lia;
   unfold lsl; unfold Zbits.lsl; rewrite (Zle_imp_le_bool _ _ Ry);
   unfold Zbits.lsl_def;
   rewrite Zbits.lsl_arithmetic_shift; unfold Zbits.lsl_arithmetic_def;
@@ -1666,11 +1665,11 @@ Proof.
                                (Cint.two_power_abs (y - (n + 1)))
                                 N).
   + auto with zarith.
-  + generalize (Cint.two_power_abs_is_positive n); fold N; omega.
+  + generalize (Cint.two_power_abs_is_positive n); fold N; lia.
   + rewrite Z.add_cancel_r. 
     replace (N + N) with (2 * N) by (auto with zarith); unfold N. 
-    rewrite <- Cint.two_power_abs_plus_one by omega.
-    rewrite <- Cint.two_power_abs_plus_pos by omega.
+    rewrite <- Cint.two_power_abs_plus_one by lia.
+    rewrite <- Cint.two_power_abs_plus_pos by lia.
     replace (n + 1 + (y - (n + 1))) with y by ring.
     auto.
 Qed.
@@ -1726,14 +1725,14 @@ Lemma is_sint8_lsl1_inf :
   forall (y:Z), ((0%Z <= y)%Z /\ (y < 7%Z)%Z) ->
   ((Cint.to_sint8 (lsl 1%Z y)) = (lsl 1%Z y)).
 Proof.
-  intros; rewrite Cint.to_sint_8; apply is_sint_lsl1_inf; omega.
+  intros; rewrite Cint.to_sint_8; apply is_sint_lsl1_inf; lia.
 Qed.
 
 (* Why3 goal *)
 Lemma is_sint8_lsl1_sup :
   forall (y:Z), (8%Z <= y)%Z -> ((Cint.to_sint8 (lsl 1%Z y)) = 0%Z).
 Proof.
-  intros; rewrite Cint.to_sint_8; apply is_sint_lsl1_sup; omega.
+  intros; rewrite Cint.to_sint_8; apply is_sint_lsl1_sup; lia.
 Qed.
 
 (** *** Cast to sint16 C type *)
@@ -1787,14 +1786,14 @@ Lemma is_sint16_lsl1_inf :
   forall (y:Z), ((0%Z <= y)%Z /\ (y < 15%Z)%Z) ->
   ((Cint.to_sint16 (lsl 1%Z y)) = (lsl 1%Z y)).
 Proof.
-  intros; rewrite Cint.to_sint_16; apply is_sint_lsl1_inf; omega.
+  intros; rewrite Cint.to_sint_16; apply is_sint_lsl1_inf; lia.
 Qed.
 
 (* Why3 goal *)
 Lemma is_sint16_lsl1_sup :
   forall (y:Z), (16%Z <= y)%Z -> ((Cint.to_sint16 (lsl 1%Z y)) = 0%Z).
 Proof.
-  intros; rewrite Cint.to_sint_16; apply is_sint_lsl1_sup; omega.
+  intros; rewrite Cint.to_sint_16; apply is_sint_lsl1_sup; lia.
 Qed.
 
 (** *** Cast to sint32 C type *)
@@ -1848,14 +1847,14 @@ Lemma is_sint32_lsl1_inf :
   forall (y:Z), ((0%Z <= y)%Z /\ (y < 31%Z)%Z) ->
   ((Cint.to_sint32 (lsl 1%Z y)) = (lsl 1%Z y)).
 Proof.
-   intros; rewrite Cint.to_sint_32; apply is_sint_lsl1_inf; omega.
+   intros; rewrite Cint.to_sint_32; apply is_sint_lsl1_inf; lia.
 Qed.
 
 (* Why3 goal *)
 Lemma is_sint32_lsl1_sup :
   forall (y:Z), (32%Z <= y)%Z -> ((Cint.to_sint32 (lsl 1%Z y)) = 0%Z).
 Proof.
-  intros; rewrite Cint.to_sint_32; apply is_sint_lsl1_sup; omega.
+  intros; rewrite Cint.to_sint_32; apply is_sint_lsl1_sup; lia.
 Qed.
 
 (** *** Cast to sint64 C type *)
@@ -1909,14 +1908,14 @@ Lemma is_sint64_lsl1_inf :
   forall (y:Z), ((0%Z <= y)%Z /\ (y < 63%Z)%Z) ->
   ((Cint.to_sint64 (lsl 1%Z y)) = (lsl 1%Z y)).
 Proof.
-  intros; rewrite Cint.to_sint_64; apply is_sint_lsl1_inf; omega.
+  intros; rewrite Cint.to_sint_64; apply is_sint_lsl1_inf; lia.
 Qed.
 
 (* Why3 goal *)
 Lemma is_sint64_lsl1_sup :
   forall (y:Z), (64%Z <= y)%Z -> ((Cint.to_sint64 (lsl 1%Z y)) = 0%Z).
 Proof.
-  intros; rewrite Cint.to_sint_64; apply is_sint_lsl1_sup; omega.
+  intros; rewrite Cint.to_sint_64; apply is_sint_lsl1_sup; lia.
 Qed.
 
 (** * Range of some bitwise operations *)
@@ -1937,8 +1936,8 @@ Proof.
   case_leq 0 x; intro.
   + apply Zbits.uint_lor_inf; trivial.
   + replace x with (-1).
-    { rewrite Zbits.lor_1; omega. }
-    omega.
+    { rewrite Zbits.lor_1; lia. }
+    lia.
 Qed.
 
 (* Why3 goal *)
@@ -1947,13 +1946,13 @@ Lemma sint_land_inf :
 Proof.
   intros x y h1 h2.
   cut (-(x+1) <= -((land x y)+1)).
-  { omega. }
+  { lia. }
   fold (Bits.zlnot x).
   fold (Bits.zlnot (land x y)).
   repeat (rewrite <- Zbits.lnot_zlnot_equiv).
   rewrite Zbits.lnot_land_de_morgan.
   repeat (rewrite Zbits.lnot_zlnot_equiv).
-  apply (uint_lor_inf (Bits.zlnot x)); unfold Bits.zlnot; try omega.
+  apply (uint_lor_inf (Bits.zlnot x)); unfold Bits.zlnot; try lia.
 Qed.
 
 (* Why3 goal *)
@@ -1963,14 +1962,14 @@ Lemma sint_lor_range :
 Proof.
   intros x y h1.
   cut (0 <= -((lor x y)+1) <= -(x+1)).
-  { omega. }
+  { lia. }
   fold (Bits.zlnot x).
   fold (Bits.zlnot (lor x y)).
   rewrite <- Zbits.lnot_zlnot_equiv.
   rewrite Zbits.lnot_lor_de_morgan.
   rewrite Zbits.lnot_zlnot_equiv.
   apply (uint_land_range (Bits.zlnot x)).
-  unfold Bits.zlnot; omega.
+  unfold Bits.zlnot; lia.
 Qed.
 
 (* Why3 goal *)
@@ -1984,14 +1983,14 @@ Proof.
     rewrite <- Zbits.lor_sign in H.
     destruct H.
     generalize H0; clear H0.
-    assert (h1:((-1) <= x)) by omega.
+    assert (h1:((-1) <= x)) by lia.
     generalize (uint_lor_inf x y h1 H1).
     rewrite Zbits.lor_commut.
-    assert (h2:((-1) <= y)) by omega.
+    assert (h2:((-1) <= y)) by lia.
     generalize (uint_lor_inf y x h2 H).
     unfold lor;
     pose (z:=(Zbits.lor y x)); fold z; intros.
-    omega.
+    lia.
   + intro H; destruct H.
     rewrite <- (is_uint_lor n) by trivial.
     apply Cint.is_to_uint.
@@ -2026,7 +2025,7 @@ Proof.
   unfold Cint.two_power_abs.
   rewrite Zbits.pos_mod_two_power_nat_land_edge.
   unfold land; f_equal.
-  unfold lsl; rewrite Zbits.lsl_pos by omega; unfold Zbits.lsl_def. 
+  unfold lsl; rewrite Zbits.lsl_pos by lia; unfold Zbits.lsl_def. 
   rewrite Zbits.lsl_arithmetic_shift; unfold Zbits.lsl_arithmetic_def.
   auto with zarith.
 Qed.
--- a/src/plugins/wp/share/coqwp/Cint.v	2021-11-29 17:00:00.000000000 -0700
+++ b/src/plugins/wp/share/coqwp/Cint.v	2021-12-07 08:29:43.771272606 -0700
@@ -31,6 +31,7 @@ Require int.Int.
 Definition is_bool (x:Z): Prop := (x = 0%Z) \/ (x = 1%Z).
 
 Require Import Qedlib.
+Require Import Lia.
 
 (** * remarks about two_power_nat *)
 Remark two_power_nat_is_positive: forall n,
@@ -42,7 +43,7 @@ Proof.
   (** ind. *) 
   + rewrite two_power_nat_S.
     apply Zmult_lt_0_compat.
-    omega.
+    lia.
     auto.
 Qed.
 
@@ -197,7 +198,7 @@ Proof.
   unfold two_power_abs.
   replace (Z.abs_nat (n + m)) with ((Z.abs_nat n) + (Z.abs_nat m))%nat.
   + rewrite two_power_nat_plus. trivial.
-  + rewrite Zabs2Nat.inj_add by omega. trivial.
+  + rewrite Zabs2Nat.inj_add by lia. trivial.
 Qed.
 
 (* Why3 goal *)
@@ -205,7 +206,7 @@ Lemma two_power_abs_plus_one : forall (n
   ((two_power_abs (n + 1%Z)%Z) = (2%Z * (two_power_abs n))%Z).
 Proof.
   intros n h1.
-  rewrite two_power_abs_plus_pos by omega.
+  rewrite two_power_abs_plus_pos by lia.
   replace (two_power_abs 1) with 2%Z.
   + ring.
   + unfold two_power_abs.
@@ -280,12 +281,12 @@ Proof.
   intros n x.
   apply is_to_range.
   generalize (two_power_abs_is_positive n); intro.
-  omega.
+  lia.
 Qed.
 
 (** * C-Integer Conversions are in-range *)
 
-Local Ltac to_range := intro x ; apply is_to_range ; omega.
+Local Ltac to_range := intro x ; apply is_to_range ; lia.
 
 (* Why3 goal *)
 Lemma is_to_uint8 : forall (x:Z), (is_uint8 (to_uint8 x)).
@@ -338,18 +339,18 @@ Proof.
     apply Z_mod_plus_full.
   + assert (k*n > 0).
     { apply Zmult_gt_0_compat; trivial. }
-    omega.
+    lia.
 Qed.			       
 
 Lemma id_to_range : forall a b x, a <= x < b -> to_range a b x = x.
 Proof.
   intros a b x Range. unfold to_range.
   assert (Q : b-a > 0) ; auto with zarith.
-  cut ((x-a) mod (b-a) = (x-a)). omega.
-  apply Zmod_small. omega.
+  cut ((x-a) mod (b-a) = (x-a)). lia.
+  apply Zmod_small. lia.
 Qed.
   
-Local Ltac id_range := intro x ; apply id_to_range ; omega.
+Local Ltac id_range := intro x ; apply id_to_range ; lia.
 
 (* Why3 goal *)
 Lemma id_uint : forall (n:Z) (x:Z), (is_uint n x) <-> ((to_uint n x) = x).
@@ -409,7 +410,7 @@ Qed.
 
 (** * C-Integer Conversions are projections *)
     
-Local Ltac proj := intro x ; apply id_to_range ; apply is_to_range ; omega.
+Local Ltac proj := intro x ; apply id_to_range ; apply is_to_range ; lia.
 
 (* Why3 goal *)
 Lemma proj_uint : forall (n:Z) (x:Z), ((to_uint n (to_uint n x)) = (to_uint n
@@ -427,7 +428,7 @@ Proof.
   unfold to_sint. apply is_to_range. 
   assert (0 < two_power_abs n).
   { apply two_power_abs_is_positive. }
-  omega.
+  lia.
 Qed.
 
 (* Why3 goal *)
@@ -490,8 +491,8 @@ Proof.
     trivial.
   + symmetry. apply Zmod_small.
     assert (0 <= x mod n2 < n2).
-    { apply Z_mod_lt; omega. }
-    omega.
+    { apply Z_mod_lt; lia. }
+    lia.
 Qed.
 
 (* Why3 goal *)
@@ -512,28 +513,28 @@ Proof.
   generalize (two_power_abs_is_positive m).
   generalize (two_power_abs_is_positive (m+n)).
 
-  rewrite two_power_abs_plus_pos by omega.
+  rewrite two_power_abs_plus_pos by lia.
   pose (n2:=(two_power_abs n)); fold n2.
   pose (m2:=(two_power_abs m)); fold m2.
   intros.
 
   replace (m2*n2 + m2*n2) with (2*(m2*n2)) by (auto with zarith).
   replace ((x mod n2 + (m2*n2)) mod (2*(m2*n2))) with (x mod n2 + (m2*n2)).
-  + omega.
+  + lia.
   + symmetry. apply Zmod_small.
     pose (r:=(x mod n2)); fold r.
     assert (0 <= r < n2).
-    { apply Z_mod_lt; omega. }
+    { apply Z_mod_lt; lia. }
     split.
-    * omega.
+    * lia.
     * replace (2*(m2*n2)) with (m2*n2 + m2*n2) by (auto with zarith).
       rewrite <- Z.add_lt_mono_r.
       pose (mn:=(m2 * n2)); fold mn.
       assert (n2 <= mn).
       { replace n2 with (1*n2) by auto with zarith.
 	      unfold mn. 
-        apply Int.CompatOrderMult; omega. }
-      destruct H2. omega.
+        apply Int.CompatOrderMult; lia. }
+      destruct H2. lia.
 Qed.
 
 (* Why3 goal *)
@@ -547,17 +548,17 @@ Proof.
   generalize (two_power_abs_is_positive m).
   generalize (two_power_abs_is_positive (m + (n + 1))).
  
-  rewrite two_power_abs_plus_pos by omega.
-  rewrite two_power_abs_plus_one by omega.
+  rewrite two_power_abs_plus_pos by lia.
+  rewrite two_power_abs_plus_one by lia.
   pose (n2:=(two_power_abs n)); fold n2.
   pose (m2:=(two_power_abs m)); fold m2.
   intros.
 
   replace (n2 + n2) with (2*n2) by (auto with zarith).
   symmetry.
-  rewrite <- (mod_kn_mod_n m2 ) by omega.
-  rewrite <- Z.add_mod_idemp_l by omega.
-  rewrite mod_kn_mod_n by omega.
+  rewrite <- (mod_kn_mod_n m2 ) by lia.
+  rewrite <- Z.add_mod_idemp_l by lia.
+  rewrite mod_kn_mod_n by lia.
   trivial.
 Qed.
 
@@ -606,15 +607,15 @@ Proof.
   repeat (rewrite Z.sub_0_r); repeat (rewrite Z.add_0_l); repeat (rewrite Z.sub_opp_r).
   generalize (two_power_abs_is_positive n).
   generalize (two_power_abs_is_positive m).
-  rewrite two_power_abs_plus_one by omega.
-  rewrite two_power_abs_plus_pos by omega.
+  rewrite two_power_abs_plus_one by lia.
+  rewrite two_power_abs_plus_pos by lia.
   pose (n2:=(two_power_abs n)); fold n2.
   pose (m2:=(two_power_abs m)); fold m2.
   intros.
   replace (m2*n2 + m2*n2) with (2*(m2*n2)) by (auto with zarith).
   rewrite Z.add_opp_l.
   symmetry.
-  rewrite <- (mod_kn_mod_n m2) by omega.
+  rewrite <- (mod_kn_mod_n m2) by lia.
   replace (m2 * (2 * n2)) with (2 * (m2 * n2)) by ring.
   pose (mn:=(m2*n2)); fold mn.
   replace x with ((x+mn)-mn) by (auto with zarith).
@@ -622,7 +623,7 @@ Proof.
   rewrite <- Zminus_mod_idemp_l. 
   unfold mn.
   replace (2 * (m2 * n2)) with (m2 * (2 * n2)) by ring.
-  rewrite mod_kn_mod_n by omega.
+  rewrite mod_kn_mod_n by lia.
   trivial.
 Qed.
 
@@ -630,7 +631,7 @@ Remark two_power_abs_increase: forall (n
 Proof.
   intros.
   generalize (two_power_abs_is_positive n); intro h.
-  rewrite two_power_abs_plus_one; omega.
+  rewrite two_power_abs_plus_one; lia.
 Qed.
 
 Require Import Qedlib.
@@ -643,15 +644,15 @@ Proof.
   { replace (n + 0) with n by ring; auto. }
   intro; unfold is_uint; intros h10 h11.
   split.
-  + omega.
+  + lia.
   + replace (n + (n0 + 1)) with ((n + n0) + 1) by ring.
     pose (m :=(n + n0)); fold m; fold m in h11.
     assert (two_power_abs m < two_power_abs (m + 1)).
-    { assert (0 <= m) by (unfold m; omega).
+    { assert (0 <= m) by (unfold m; lia).
       clear h11 h2 x h3 i h1 h10.
       apply two_power_abs_increase; auto.
     }
-    omega.
+    lia.
 Qed.
 
 (* Why3 goal *)
@@ -665,9 +666,9 @@ Proof.
   replace (n + (n0 + 1)) with ((n + n0) + 1) by ring.
   pose (m :=(n + n0)); fold m; fold m in h11.
   assert (0 <= m).
-  { unfold m; omega. }
+  { unfold m; lia. }
   generalize (two_power_abs_increase m); intro.
-  omega.
+  lia.
 Qed.
 
 (* Why3 goal *)
@@ -677,14 +678,14 @@ Proof.
   intros n x i h1 h2 h3.
   unfold is_sint; unfold is_uint in h3.
   apply Qedlib.Z_induction_rank with (m:=0) (n := i) ; auto with zarith.
-  { replace (n + 0) with n by ring; omega. }
+  { replace (n + 0) with n by ring; lia. }
   intro.
   replace (n + (n0 + 1)) with ((n + n0) + 1) by ring.
   pose (m :=(n + n0)); fold m; intros.
   assert (0 <= m).
-  { unfold m; omega. }
+  { unfold m; lia. }
   generalize (two_power_abs_increase m); intro.
-  omega.
+  lia.
 Qed.
 
 Require Import Zbits.
--- a/src/plugins/wp/share/coqwp/int/Abs.v	2021-11-29 17:00:00.000000000 -0700
+++ b/src/plugins/wp/share/coqwp/int/Abs.v	2021-12-07 08:29:43.772272606 -0700
@@ -14,6 +14,7 @@
 Require Import BuiltIn.
 Require BuiltIn.
 Require int.Int.
+Require Import Lia.
 
 (* Why3 comment *)
 (* abs is replaced with (ZArith.BinInt.Z.abs x) by the coq driver *)
@@ -39,7 +40,7 @@ Lemma Abs_le :
   ((ZArith.BinInt.Z.abs x) <= y)%Z <-> (((-y)%Z <= x)%Z /\ (x <= y)%Z).
 intros x y.
 zify.
-omega.
+lia.
 Qed.
 
 (* Why3 goal *)
--- a/src/plugins/wp/share/coqwp/int/ComputerDivision.v	2021-11-29 17:00:00.000000000 -0700
+++ b/src/plugins/wp/share/coqwp/int/ComputerDivision.v	2021-12-07 08:29:43.772272606 -0700
@@ -17,6 +17,7 @@ Require int.Int.
 Require int.Abs.
 
 Require Import Zquot.
+Require Import Lia.
 
 (* Why3 comment *)
 (* div is replaced with (ZArith.BinInt.Z.quot x x1) by the coq driver *)
@@ -46,7 +47,7 @@ apply Z.le_refl.
 destruct (Zle_lt_or_eq 0 x Hx) as [H'|H'].
 apply Zlt_le_weak.
 apply Z.quot_lt with (1 := H').
-omega.
+lia.
 now rewrite <- H', Zquot_0_l.
 Qed.
 
@@ -58,10 +59,10 @@ Lemma Mod_bound :
 intros x y Zy.
 destruct (Zle_or_lt 0 x) as [Hx|Hx].
 refine ((fun H => conj (Z.lt_le_trans _ 0 _ _ (proj1 H)) (proj2 H)) _).
-clear -Zy ; zify ; omega.
+clear -Zy ; zify ; lia.
 now apply Zrem_lt_pos.
 refine ((fun H => conj (proj1 H) (Z.le_lt_trans _ 0 _ (proj2 H) _)) _).
-clear -Zy ; zify ; omega.
+clear -Zy ; zify ; lia.
 apply Zrem_lt_neg with (2 := Zy).
 now apply Zlt_le_weak.
 Qed.
@@ -81,7 +82,7 @@ Lemma Div_sign_neg :
 intros x y (Hx, Hy).
 generalize (Z.quot_pos (-x) y).
 rewrite Zquot_opp_l.
-omega.
+lia.
 Qed.
 
 (* Why3 goal *)
@@ -110,7 +111,7 @@ rewrite Zmult_comm.
 zify.
 generalize (Z.mul_quot_le x y).
 generalize (Z.mul_quot_ge x y).
-omega.
+lia.
 Qed.
 
 (* Why3 goal *)
--- a/src/plugins/wp/share/coqwp/int/ComputerOfEuclideanDivision.v	2021-11-29 17:00:00.000000000 -0700
+++ b/src/plugins/wp/share/coqwp/int/ComputerOfEuclideanDivision.v	2021-12-07 08:29:43.772272606 -0700
@@ -20,6 +20,7 @@ Require int.Int.
 Require int.Abs.
 Require int.EuclideanDivision.
 Require int.ComputerDivision.
+Require Import Lia.
 
 Lemma on_pos_euclidean_is_div:
   forall n d, (int.EuclideanDivision.div n (Zpos d)) = Z.div n (Zpos d).
@@ -82,7 +83,7 @@ Lemma cmod_cases :
   unfold int.EuclideanDivision.mod1.
   assert (Z.rem n d = n - (d * (Z.quot n d)))%Z.
   assert (H:= Z.quot_rem' n d).
-  omega.
+  lia.
   rewrite H.
   assert (H2:=cdiv_cases n d).
   intuition idtac.
@@ -90,13 +91,13 @@ Lemma cmod_cases :
     reflexivity.
   + rewrite H4.
     rewrite Z.mul_opp_r.
-    omega.
+    lia.
   + rewrite H1.
     rewrite Z.mul_opp_r.
     rewrite Z.mul_opp_l.
     reflexivity.
   + rewrite H4.
     rewrite Z.mul_opp_l.
-    omega.
+    lia.
 Qed.
 
--- a/src/plugins/wp/share/coqwp/int/EuclideanDivision.v	2021-11-29 17:00:00.000000000 -0700
+++ b/src/plugins/wp/share/coqwp/int/EuclideanDivision.v	2021-12-07 08:29:43.772272606 -0700
@@ -18,6 +18,7 @@ Require Import BuiltIn.
 Require BuiltIn.
 Require int.Int.
 Require int.Abs.
+Require Import Lia.
 
 (* Why3 goal *)
 Definition div : Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.
@@ -54,10 +55,10 @@ assert (H2 := Z_mod_lt x y).
 unfold mod1, div.
 case Z_le_dec ; intros H0.
 rewrite Zmult_comm, <- Zmod_eq_full with (1 := Zy).
-omega.
+lia.
 replace (x - y * (x / y + 1))%Z with (x - x / y * y - y)%Z by ring.
 rewrite <- Zmod_eq_full with (1 := Zy).
-omega.
+lia.
 Qed.
 
 (* Why3 goal *)
@@ -66,22 +67,22 @@ Lemma Div_unique :
   (0%Z < y)%Z -> ((q * y)%Z <= x)%Z /\ (x < ((q * y)%Z + y)%Z)%Z ->
   ((div x y) = q).
 intros x y q h1 (h2,h3).
-assert (h:(~(y=0))%Z) by omega.
+assert (h:(~(y=0))%Z) by lia.
 generalize (Mod_bound x y h); intro h0.
 rewrite Z.abs_eq in h0; auto with zarith.
 generalize (Div_mod x y h); clear h; intro h.
-assert (cases:(div x y = q \/ (div x y <= q - 1 \/ div x y >= q+1))%Z) by omega.
+assert (cases:(div x y = q \/ (div x y <= q - 1 \/ div x y >= q+1))%Z) by lia.
 destruct cases as [h4 | [h5 | h6]]; auto.
 assert (y * div x y <= y * (q - 1))%Z.
  apply  Zmult_le_compat_l; auto with zarith.
 replace (y*(q-1))%Z with (q*y - y)%Z in H by ring.
 elimtype False.
-omega.
+lia.
 assert (y * div x y >= y * (q + 1))%Z.
  apply  Zmult_ge_compat_l; auto with zarith.
 replace (y*(q+1))%Z with (q*y + y)%Z in H by ring.
 elimtype False.
-omega.
+lia.
 Qed.
 
 (* Why3 goal *)
@@ -99,7 +100,7 @@ rewrite H', Zdiv_1_r.
 apply Z.le_refl.
 rewrite <- (Zdiv_1_r x) at 2.
 apply Zdiv_le_compat_l with (1 := Hx).
-omega.
+lia.
 elim H.
 apply Z_mod_lt.
 now apply Z.lt_gt.
@@ -137,7 +138,7 @@ Lemma Div_inf_neg :
   forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
   (0%Z < x)%Z /\ (x <= y)%Z -> ((div (-x)%Z y) = (-1%Z)%Z).
 intros x y Hxy.
-assert (h: (x < y \/ x = y)%Z) by omega.
+assert (h: (x < y \/ x = y)%Z) by lia.
 destruct h.
 (* case 0 < x < y *)
 assert (h1: (x mod y = x)%Z).
--- a/src/plugins/wp/share/coqwp/int/Exponentiation.v	2021-11-29 17:00:00.000000000 -0700
+++ b/src/plugins/wp/share/coqwp/int/Exponentiation.v	2021-12-07 08:29:43.772272606 -0700
@@ -14,6 +14,7 @@
 Require Import BuiltIn.
 Require BuiltIn.
 Require int.Int.
+Require Import Lia.
 
 Section Exponentiation.
 
@@ -69,7 +70,7 @@ Lemma Power_s_alt :
 Proof.
 intros x n h1.
 rewrite <- Power_s; auto with zarith.
-f_equal; omega.
+f_equal; lia.
 Qed.
 
 (* Why3 goal *)
--- a/src/plugins/wp/share/coqwp/int/MinMax.v	2021-11-29 17:00:00.000000000 -0700
+++ b/src/plugins/wp/share/coqwp/int/MinMax.v	2021-12-07 08:29:43.772272606 -0700
@@ -14,6 +14,7 @@
 Require Import BuiltIn.
 Require BuiltIn.
 Require int.Int.
+Require Import Lia.
 
 (* Why3 comment *)
 (* min is replaced with (ZArith.BinInt.Z.min x x1) by the coq driver *)
@@ -28,7 +29,7 @@ intros x y.
 split ; intros H.
 now apply Z.min_l.
 apply Z.min_r.
-omega.
+lia.
 Qed.
 
 (* Why3 comment *)
@@ -44,7 +45,7 @@ intros x y.
 split ; intros H.
 now apply Z.max_r.
 apply Z.max_l.
-omega.
+lia.
 Qed.
 
 (* Why3 goal *)
--- a/src/plugins/wp/share/coqwp/int/Power.v	2021-11-29 17:00:00.000000000 -0700
+++ b/src/plugins/wp/share/coqwp/int/Power.v	2021-12-07 08:29:43.773272606 -0700
@@ -16,6 +16,7 @@ Require BuiltIn.
 Require int.Int.
 
 Require Import Exponentiation.
+Require Import Lia.
 
 (* Why3 goal *)
 Notation power := Zpower.
@@ -57,7 +58,7 @@ Lemma Power_s_alt :
 intros x n h1.
 rewrite <- Power_s.
 f_equal; auto with zarith.
-omega.
+lia.
 Qed.
 
 (* Why3 goal *)
--- a/src/plugins/wp/share/coqwp/Memory.v	2021-11-29 17:00:00.000000000 -0700
+++ b/src/plugins/wp/share/coqwp/Memory.v	2021-12-07 08:29:43.773272606 -0700
@@ -31,6 +31,7 @@ Require map.Map.
 
 Require Import ZArith.
 Require Import Qedlib.
+Require Import Lia.
 
 (* Why3 assumption *)
 Inductive addr :=
@@ -236,7 +237,7 @@ Proof.
   rewrite BaseP in BaseQ.
   contradiction.
   rewrite <- EQ in InQ1,InQ2.
-  omega.
+  lia.
 Qed.
 
 (* Why3 goal *)
--- a/src/plugins/wp/share/coqwp/Qedlib.v	2021-11-29 17:00:00.000000000 -0700
+++ b/src/plugins/wp/share/coqwp/Qedlib.v	2021-12-07 08:29:43.773272606 -0700
@@ -23,6 +23,7 @@
 Require Import Bool.
 Require Import ZArith.
 Require Import Reals.
+Require Import Lia.
 
 Require BuiltIn.
 Require map.Map.
@@ -39,7 +40,7 @@ Ltac forward :=
   try contradiction ;
   try tauto ;
   try constructor ;
-  try (apply False_ind ; omega ; fail) ;
+  try (apply False_ind ; lia ; fail) ;
   try (apply False_ind ; auto with zarith ; fail) ;
   auto with zarith.
 
@@ -85,13 +86,13 @@ Definition boolean {A : Set}
 *)
 
 Ltac case_leq x y :=
-  generalize (Zle_cases x y) ; induction (Zle_bool x y) ; try omega.
+  generalize (Zle_cases x y) ; induction (Zle_bool x y) ; try lia.
 
 Ltac case_lt x y :=
-  generalize (Zlt_cases x y) ; induction (Zlt_bool x y) ; try omega.
+  generalize (Zlt_cases x y) ; induction (Zlt_bool x y) ; try lia.
 
 Ltac case_eq x y :=
-  generalize (Zeq_bool_if x y) ; induction (Zeq_bool x y) ; try omega.
+  generalize (Zeq_bool_if x y) ; induction (Zeq_bool x y) ; try lia.
 
 Lemma Zneq_cases : forall x y, if Zneq_bool x y then x <> y else x = y.
 Proof.
@@ -103,7 +104,7 @@ Proof.
 Qed.
 
 Ltac case_neq x y :=
-  generalize (Zneq_cases x y) ; induction (Zneq_bool x y) ; try omega.
+  generalize (Zneq_cases x y) ; induction (Zneq_bool x y) ; try lia.
 
 Inductive Zcases (x y : Z) :=
   | Case_lt : (x < y) -> Zcases x y
@@ -115,7 +116,7 @@ Proof.
   intros.
   case_leq x y.
   case_lt x y. intros H _. exact (Case_lt H).
-  intros H1 H2. assert (H : x=y) by omega. exact (Case_eq H).
+  intros H1 H2. assert (H : x=y) by lia. exact (Case_eq H).
   intro H. exact (Case_gt H).
 Qed.
 
@@ -343,5 +344,5 @@ Proof.
   generalize (Z_mod_lt n d).
   intro R. generalize (R Dpos). clear R. fold r.
   replace (d*x) with (x*d) by ring.
-  omega.
+  lia.
 Qed.
--- a/src/plugins/wp/share/coqwp/Vlist.v	2021-11-29 17:00:00.000000000 -0700
+++ b/src/plugins/wp/share/coqwp/Vlist.v	2021-12-07 08:29:43.773272606 -0700
@@ -129,12 +129,12 @@ Proof.
         by( (replace (a0 :: w) with ([a0] ++ w) by seq); rewrite List.app_length; by seq).
       assert (0 <= Z.of_nat (Datatypes.length w)) by apply Zle_0_nat.
       replace (Z.of_nat (1 + Datatypes.length w)) with (1 + Z.of_nat (Datatypes.length w)).
-      { omega. }
+      { lia. }
       rewrite Nat2Z.inj_add. 
       auto with zarith. 
     }
     intro. 
-    cut False; [contradiction|omega].
+    cut False; [contradiction|lia].
 Qed.
 
 (* Why3 goal *)
@@ -214,11 +214,11 @@ Proof.
   (* + generalize (nth_concat nil w i); rewrite length_nil; intro G; destruct G.
     rewrite H1.
     * replace (i - 0)%Z with i by (auto with zarith). auto.
-    * omega. *)
+    * lia. *)
   + generalize (nth_concat w nil i). intro G; destruct G.
     rewrite H0.
     * auto.
-    * omega.
+    * lia.
 Qed.
 
 (* Why3 goal *)
@@ -255,7 +255,7 @@ Proof.
     * clear H1; rewrite H0; clear H0; auto.
       generalize (nth_concat (cons x v) w i); rewrite length_cons; intro G; destruct G.
       generalize (length_pos v); intro Positive.
-      clear H1; rewrite H0 by omega; clear H0.
+      clear H1; rewrite H0 by lia; clear H0.
       generalize (nth_cons i x v); intro G; destruct G.
       clear H1; rewrite H0; clear H0; auto.
     * clear H0; rewrite H1; clear H1; auto.
@@ -312,22 +312,22 @@ Proof.
       generalize (nth_concat u (concat v w) i) ; intro G; destruct G.
     + clear H1; rewrite H0 by auto; clear H0.
       generalize (nth_concat (concat u v) w i) ; rewrite length_concat ; intro G; destruct G.
-      clear H1; rewrite H0 by omega; clear H0.
+      clear H1; rewrite H0 by lia; clear H0.
       generalize (nth_concat u v i) ; intro G; destruct G.
       clear H1; rewrite H0 by auto; clear H0.
       auto.
    + clear H0; rewrite H1 by auto; clear H1.
      case_lt i ((length u) + (length v)); intro inV; 
        generalize (nth_concat (concat u v) w i) ; rewrite length_concat ; intro G; destruct G.
-     * clear H1; rewrite H0 by omega; clear H0.
+     * clear H1; rewrite H0 by lia; clear H0.
        generalize (nth_concat u v i) ; intro G; destruct G.
        clear H0; rewrite H1 by auto; clear H1.
        generalize (nth_concat v w (i - length u)) ; intro G; destruct G.
-       clear H1; rewrite H0 by omega; clear H0.
+       clear H1; rewrite H0 by lia; clear H0.
        auto.
-     * clear H0; rewrite H1 by omega; clear H1.
+     * clear H0; rewrite H1 by lia; clear H1.
        generalize (nth_concat v w (i - length u)) ; intro G; destruct G.
-       clear H0; rewrite H1 by omega; clear H1.
+       clear H0; rewrite H1 by lia; clear H1.
        replace (i - (length u + length v)) with (i - length u - length v) by auto with zarith.
        auto.
 Qed.
--- a/src/plugins/wp/share/coqwp/Zbits.v	2021-11-29 17:00:00.000000000 -0700
+++ b/src/plugins/wp/share/coqwp/Zbits.v	2021-12-07 08:29:43.774272607 -0700
@@ -45,10 +45,11 @@ Require Import FunctionalExtensionality.
 Require Import Qedlib.
 Require Import Bits.
 Require Import Psatz.
+Require Import Lia.
 
 Local Open Scope Z_scope.
 
-Local Ltac omegaContradiction := cut False; [contradiction|omega].
+Local Ltac liaContradiction := cut False; [contradiction|lia].
 
 Local Ltac caseEq name :=
   generalize (refl_equal name); pattern name at -1 in |- *; case name.
@@ -87,7 +88,7 @@ Qed.
 Lemma split_range: forall a x b: Z, 
   a <= x -> x < b -> a <= x < b.
 Proof.
-  intros. omega.
+  intros. lia.
 Qed.
 
 (** Some remarks about absolute value *)
@@ -96,14 +97,14 @@ Remark zabs_gt: forall n m: Z,
   Z.abs m < Z.abs n -> (Z.abs_nat m < Z.abs_nat n)%nat.
 Proof. 
   intros. apply (inj_lt_rev (Z.abs_nat m) (Z.abs_nat n)).
-  rewrite (inj_Zabs_nat n). rewrite (inj_Zabs_nat m). omega.
+  rewrite (inj_Zabs_nat n). rewrite (inj_Zabs_nat m). lia.
 Qed.
 					 
 Remark zabs_le: forall n m: Z,
   Z.abs n <= Z.abs m -> (Z.abs_nat n <= Z.abs_nat m)%nat.
 Proof.
   intros. apply (inj_le_rev (Z.abs_nat n) (Z.abs_nat m)).
-  rewrite (inj_Zabs_nat n). rewrite (inj_Zabs_nat m). omega.
+  rewrite (inj_Zabs_nat n). rewrite (inj_Zabs_nat m). lia.
 Qed.
 					 
 Remark zabs_le_plus: forall (n m:Z) (k: nat),
@@ -112,7 +113,7 @@ Proof.
   intros. 
   apply (inj_le_rev (Z.abs_nat n) (k + Z.abs_nat m)%nat).
   rewrite (inj_Zabs_nat n). rewrite inj_plus. rewrite (inj_Zabs_nat m).
-  omega.
+  lia.
 Qed.
 					 
 Remark zabs_nat_zabs: forall n: Z,
@@ -126,7 +127,7 @@ Remark zabs_minus: forall n m: Z,
   Z.abs n <= Z.abs m -> (Z.abs_nat m - Z.abs_nat n)%nat = Z.abs_nat (Z.abs m - Z.abs n).
 Proof.
   intros. 
-  rewrite Zabs_nat_Zminus by (generalize (Zabs_pos n); omega).
+  rewrite Zabs_nat_Zminus by (generalize (Zabs_pos n); lia).
   repeat rewrite zabs_nat_zabs. 
   auto.
 Qed.
@@ -137,8 +138,8 @@ Proof.
   intros. 
   rewrite Zabs_nat_Zplus.
   (** cont. *) repeat rewrite zabs_nat_zabs; auto.
-  (** hyp 1 *) generalize (Zabs_pos m); omega.
-  (** hyp 2 *) generalize (Zabs_pos n); omega.
+  (** hyp 1 *) generalize (Zabs_pos m); lia.
+  (** hyp 2 *) generalize (Zabs_pos n); lia.
 Qed.
 
 (** Some remarks about Zle_bool and Zlt_bool *)
@@ -155,9 +156,9 @@ Proof.
   intro x.
   case_leq 0 (x/2); case_leq 0 x; try auto; intros; apply False_ind.
   (** 0>x *)
-  + assert (x/2 < 0); [ apply Zdiv_lt_upper_bound | ]; omega.
+  + assert (x/2 < 0); [ apply Zdiv_lt_upper_bound | ]; lia.
   (** 0<=x *)
-  + assert (0 <= (x/2)); [ apply Z_div_pos | ]; omega.
+  + assert (0 <= (x/2)); [ apply Z_div_pos | ]; lia.
 Qed.
 
 Remark Zlt_div2_neg: forall x:Z,
@@ -166,12 +167,12 @@ Proof.
   intro x.
   case_lt (x/2) 0; case_lt x 0; intros; try auto.
   (** x>=0 *)
-  + assert (x/2 >= 0) by (apply Z_div_ge0 ; omega).
-    omegaContradiction.
+  + assert (x/2 >= 0) by (apply Z_div_ge0 ; lia).
+    liaContradiction.
   (** x<0 *)
   + apply False_ind.
-    assert (x/2 < 0) by (apply Zdiv_lt_upper_bound; omega).
-    omegaContradiction.
+    assert (x/2 < 0) by (apply Zdiv_lt_upper_bound; lia).
+    liaContradiction.
  Qed.
 		     
 (** Some useful properties *)
@@ -181,7 +182,7 @@ Remark upper_positive_mult_positive: for
 Proof.
   intros.
   rewrite <- Zmult_1_r at 1.
-  apply Zmult_le_compat_l; omega.
+  apply Zmult_le_compat_l; lia.
 Qed.
 						       
 Remark lower_negative_mult_positive: forall p x: Z,
@@ -189,9 +190,9 @@ Remark lower_negative_mult_positive: for
 Proof.
   intros.
   cut (-x <= -(x * p)).
-    omega.
+    lia.
   rewrite Zopp_mult_distr_l.
-  apply upper_positive_mult_positive; omega.
+  apply upper_positive_mult_positive; lia.
 Qed.
 
 Theorem Z2_induction(P: Z -> Prop) :
@@ -210,7 +211,7 @@ Proof.
       rewrite H2 in *.
       apply (H0 false ((Z.pos p))); auto with zarith.
     * apply (H0 true 0); auto with zarith.
-  + generalize (Pos2Z.neg_is_neg p); intro; omegaContradiction.
+  + generalize (Pos2Z.neg_is_neg p); intro; liaContradiction.
 Qed.
  
 (** Some useful properties about modulus *)
@@ -248,12 +249,12 @@ Proof.
   + destruct p. 
     (** 2p+1 *)
     * rewrite <- (Z.mod_unique (Z.pos p~1) 2 (Z.pos p) 1) ;
-        [ | omega | (auto with zarith)].
+        [ | lia | (auto with zarith)].
       (replace (Z.pos p~1) with ( 1 + 2*Z.pos p) by forward).
       rewrite Z.odd_add_mul_2; auto.
     (** 2p+0 *)
     * rewrite <- (Z.mod_unique (Z.pos p~0) 2 (Z.pos p) 0);
-        [ | omega | (auto with zarith)].
+        [ | lia | (auto with zarith)].
       (replace (Z.pos p~0) with ( 0 + 2*Z.pos p) by forward).
       rewrite Z.odd_add_mul_2; auto.
     (** 1 *)
@@ -262,14 +263,14 @@ Proof.
   + destruct p. 
     (** 2p+1 *)
     * rewrite <- (Z.mod_unique (Z.neg p~1) 2 ((Z.neg p)-1) 1);
-        [ | omega
+        [ | lia
           | rewrite Zmult_minus_distr_l; rewrite Pos2Z.neg_xI;
             ring].   
       (replace (Z.neg p~1) with ( (-1) + 2*(Z.neg p)) by (simpl; auto)).
       rewrite Z.odd_add_mul_2; auto.
     (** 2p+0 *)
     * rewrite <- (Z.mod_unique (Z.neg p~0) 2 (Z.neg p) 0);     
-        [ | omega | simpl; auto].
+        [ | lia | simpl; auto].
       (replace (Z.neg p~0) with ( 0 + 2*Z.neg p) by (simpl; auto)).
          rewrite Z.odd_add_mul_2; simpl; auto. 
     (** 1 *)
@@ -374,12 +375,12 @@ Proof.
   (** case 0<=x *)
   + case_leq 0 (2*x + 1) ; intro.
        unfold Nabs. unfold N_decomp. unfold P_decomp. destruct x; auto.
-       assert (Z.neg p < 0) by apply (Zlt_neg_0 p); omegaContradiction.
+       assert (Z.neg p < 0) by apply (Zlt_neg_0 p); liaContradiction.
   (** case 0<=x *)
   + case_leq 0 (2*x + 1) ; intro.
     unfold zlnot; destruct x; 
       [ discriminate H 
-      | assert (Z.pos p > 0) by apply (Zgt_pos_0 p); omegaContradiction
+      | assert (Z.pos p > 0) by apply (Zgt_pos_0 p); liaContradiction
       |].
     destruct p; simpl; auto.
 Qed.
@@ -408,16 +409,16 @@ Proof.
     (** 2p+1 *)
     * rewrite <- (Z.mod_unique (Z.pos p~1) 2 (Z.pos p) 1);
         [ auto | | auto].
-      clear POS ; omega.
+      clear POS ; lia.
     (** 2p *)
     * rewrite <- (Z.mod_unique (Z.pos p~0) 2 (Z.pos p) 0);
         [ auto | | auto].
-       clear POS ; omega.
+       clear POS ; lia.
     (** 1 *)
     * compute ; auto.
   (** Negative *)
   + assert ( Z.neg p < 0) by apply Zlt_neg_0.
-    omegaContradiction.
+    liaContradiction.
 Qed.
 
 Lemma Zbit_0: forall x: Z,
@@ -467,11 +468,11 @@ Proof.
     destruct p.
     (** -(2p+1) *)
     * rewrite <- (Zdiv_unique (Zneg (xI (p)) ) 2 (Zneg p - 1) 1);
-         [ (replace (Zneg p - 1 + 1) with (Zneg p) by omega);
+         [ (replace (Zneg p - 1 + 1) with (Zneg p) by lia);
            (replace (-Zneg p) with (Zpos p) by (compute;forward));     
            (replace (-(Zneg (xI (p)) + 1)) with (Zpos (xO(p))) by (compute;forward))
          | 
-         | (replace (2*(Zneg p - 1) + 1) with (2*Zneg p - 1) by omega)
+         | (replace (2*(Zneg p - 1) + 1) with (2*Zneg p - 1) by lia)
          ]; by compute.
     (** -2p *)
     * rewrite <- (Zdiv_unique (Zneg (xO (p)) ) 2 (Zneg p) 0); 
@@ -505,14 +506,14 @@ Proof.
     rewrite Euc.
     case_mod2 x; destruct c as [] eqn:Carry.
     * rewrite EVEN in *.
-      cut ((x/2)<=z). { intro; omega. }
+      cut ((x/2)<=z). { intro; lia. }
       generalize (H0 (x/2)); clear H0; intro h0.
       apply h0; clear h0; intro.
       generalize (H1 (S k)); clear H1; intro h1.
       rewrite Zbit_s2x_p in h1.
       intro. apply h1. rewrite <- Zbit_div2; auto.
     * rewrite EVEN in *.
-      cut ((x/2)<=z). { intro; omega. }
+      cut ((x/2)<=z). { intro; lia. }
       generalize (H0 (x/2)); clear H0; intro h0.
       apply h0; clear h0; intro.
       generalize (H1 (S k)); clear H1; intro h1.
@@ -520,7 +521,7 @@ Proof.
       rewrite Zbit_2x_p in h1.
       intro. apply h1. rewrite <- Zbit_div2; auto.
     * rewrite ODD.
-      cut ((x/2)<=z). { intro; omega. }
+      cut ((x/2)<=z). { intro; lia. }
       generalize (H0 (x/2)); clear H0; intro h0.
       apply h0; clear h0; intro.
       generalize (H1 (S k)); clear H1; intro h1.
@@ -557,29 +558,29 @@ Lemma Zbit_shift_l: forall (n m:nat) (x:
 Proof.
   induction n; intros.
   (** base *)
-  + rewrite (leb_correct O m) by omega.			
+  + rewrite (leb_correct O m) by lia.			
     unfold two_power_nat. unfold shift_nat. rewrite <- (minus_n_O m).
-    f_equal. simpl. omega.
+    f_equal. simpl. lia.
   (** ind. *) 
   + rewrite two_power_nat_S.
     (replace (x * (2*two_power_nat n)) with ((2*x) * two_power_nat n) by ring).
     rewrite (IHn m (2*x)).
     nat_compare Inf EQ Sup n m.
     (** n<m *) 
-    * rewrite (leb_correct n m) by omega.
-      rewrite (leb_correct (S n) m) by omega.
+    * rewrite (leb_correct n m) by lia.
+      rewrite (leb_correct (S n) m) by lia.
       rewrite <-(Zbit_2x_p (m - S n) x).
       f_equal. 
-      rewrite (minus_Sn_m) by omega. 
+      rewrite (minus_Sn_m) by lia. 
       by simpl.
    (** n=m *) 
-    * rewrite (leb_correct n n) by omega.
-      rewrite (leb_correct_conv n (S n)) by omega.
+    * rewrite (leb_correct n n) by lia.
+      rewrite (leb_correct_conv n (S n)) by lia.
       rewrite <- minus_n_n.
       apply Zbit_2x_0.  
    (** n>m *) 
-    * rewrite (leb_correct_conv m n) by omega.
-      rewrite (leb_correct_conv m (S n)) by omega.
+    * rewrite (leb_correct_conv m n) by lia.
+      rewrite (leb_correct_conv m (S n)) by lia.
       auto. 
 Qed.
 
@@ -600,7 +601,7 @@ Proof.
       (replace (Z.pos p~0) with (2 * Z.pos p) by (auto with zarith)); auto. 
     (* 1 *)
       (replace (1) with (2 * 0 + 1) by (auto with zarith)).
-	apply H1. omega. auto.
+	apply H1. lia. auto.
   (* Neg *)
     compute in H2.
     intuition congruence.
@@ -617,7 +618,7 @@ Proof.
   + rewrite two_power_nat_S.
     (replace (2*two_power_nat n) with ((two_power_nat n)*2) by ring).
     rewrite <- Zdiv_Zdiv;
-      [ | generalize (two_power_nat_is_positive n); omega | omega].
+      [ | generalize (two_power_nat_is_positive n); lia | lia].
     rewrite (plus_Snm_nSm n m).  
     rewrite <- (IHn (S m) x). 
     apply Zbit_div2.
@@ -709,13 +710,13 @@ Proof.
   (** base *)
   + (replace (two_power_nat 0) with 1 by forward).
     case_lt z 0; intros.
-    (** z<0 *) (replace z with (-1) by (omega);forward).
-    (** z>=0*) (replace z with 0 by omega); by forward.
+    (** z<0 *) (replace z with (-1) by (lia);forward).
+    (** z>=0*) (replace z with 0 by lia); by forward.
   (** ind. *)
   + rewrite two_power_nat_S; intro.
     rewrite <-Zbit_div2.
     assert ((- two_power_nat n) <= z/2 < two_power_nat n) by
-      (split ; [apply Zdiv_le_lower_bound | apply Zdiv_lt_upper_bound] ; omega).
+      (split ; [apply Zdiv_le_lower_bound | apply Zdiv_lt_upper_bound] ; lia).
     assert (Zbit (z/2) n = ((z/2) <? 0)) by (by apply (IHn (z/2))).
     rewrite H1; apply Zlt_div2_neg.
 Qed.
@@ -733,7 +734,7 @@ Proof.
     rewrite <- plus_n_Sm.
     rewrite <-Zbit_div2.
     assert ((- two_power_nat n) <= z/2 < two_power_nat n) by
-      (split ; [apply Zdiv_le_lower_bound | apply Zdiv_lt_upper_bound] ; omega).
+      (split ; [apply Zdiv_le_lower_bound | apply Zdiv_lt_upper_bound] ; lia).
     assert (Zbit (z/2) (n + i)%nat = (z/2 <? 0)) by (by apply (IHi (z/2))).	
     rewrite H1; apply Zlt_div2_neg.
 Qed.
@@ -752,13 +753,13 @@ Lemma Zbit_unsigned_trail: forall (n i:
    (n <= i)%nat -> 0 <= z < two_power_nat n -> (Zbit z i = false).
 Proof. 
   intros n i z h1.
-  (* work around a problem with "try omega" inside case_lt *)
+  (* work around a problem with "try lia" inside case_lt *)
   pose (b:=two_power_nat n); fold b.
   intro h2.
   (replace false with (Zlt_bool z 0) by (case_lt z 0; auto)).
   apply (Zbit_trail n); auto.
   fold b.
-  omega.
+  lia.
 Qed.
 
 Lemma Zbit_trail_plus_inv: forall (n: nat) (z: Z),
@@ -772,11 +773,11 @@ Proof.
     (** z<0 *) 
     * replace z with (-1);
         [| symmetry; apply Zbit_ext; extensionality k; unfold TRUE; apply h0]. 
-      omega.
+      lia.
     (** z>=0*) 
     * replace z with 0;
         [| symmetry; apply Zbit_ext; extensionality k; unfold FALSE; apply h0].
-      omega.
+      lia.
   (** ind. *)
   + intro.
     generalize (div2_mod2_eq z); intro Euc.
@@ -814,7 +815,7 @@ Proof.
      intro h0.
      replace z with 0;
        [| symmetry; apply Zbit_ext; extensionality k; unfold FALSE; apply h0].
-     omega.
+     lia.
   (** ind. *)
   + intro.
     generalize (div2_mod2_eq z); intro Euc.
@@ -881,16 +882,16 @@ Next Obligation.
   intro Tx. intro k.
   nat_compare Inf EQ Sup n k.
   (** n < k *) 
-  + rewrite (leb_correct n k) by omega.
-    intros. rewrite (Tx (k - n)%nat) by omega.  
+  + rewrite (leb_correct n k) by lia.
+    intros. rewrite (Tx (k - n)%nat) by lia.  
     auto.
   (** n = k *)
-  + rewrite (leb_correct n n) by omega.
-    intros. rewrite (Tx (n - n)%nat) by omega.
+  + rewrite (leb_correct n n) by lia.
+    intros. rewrite (Tx (n - n)%nat) by lia.
     auto.
   (** n > k *) 
   + intro.
-    omegaContradiction.
+    liaContradiction.
 Qed.
 
 Program Definition bitwise_lsr (x: bits) (n:nat): bits :=
@@ -944,7 +945,7 @@ Proof.
   extensionality x; extensionality n; Zbit_ext k.
   (** right term *)
   unfold lsr_arithmetic_def; rewrite (Zbit_shift_r n k x);
-    (replace (n+k)%nat with (k+n)%nat by omega).
+    (replace (n+k)%nat with (k+n)%nat by lia).
   (** left term *) 
   unfold lsr_shift_def; unfold Zbit; rewrite Z_decomp_recomp;
     unfold bitwise_lsr; unfold btest.
@@ -965,8 +966,8 @@ Next Obligation.
   unfold trailing.
   intros Ty Tx k Max.
   rewrite Tx. rewrite Ty. trivial.
-  generalize (Max.max_lub_r (bsize x) (bsize y) k). omega.
-  generalize (Max.max_lub_l (bsize x) (bsize y) k). omega.
+  generalize (Max.max_lub_r (bsize x) (bsize y) k). lia.
+  generalize (Max.max_lub_l (bsize x) (bsize y) k). lia.
 Qed.
 
 Definition Z_bitwise (f: bool -> bool -> bool) (x y: Z): Z :=
@@ -1001,7 +1002,7 @@ Proof.
       (last (fun i : nat => f (btest (bits_of_Z x) i) (btest (bits_of_Z y) i))
       (ZxHpos x) (f (bsign (bits_of_Z x)) (bsign (bits_of_Z y))))
       (f (bsign (bits_of_Z x)) (bsign (bits_of_Z y)))); intro.
-    omega.
+    lia.
   (** cont. (ZxHpos x <= ZxHpos y) *)
   + rewrite Max.max_r by auto.
     generalize (last_leq (fun i: nat => f (btest (bits_of_Z x) i) (btest (bits_of_Z y) i))
@@ -1010,7 +1011,7 @@ Proof.
       (last (fun i: nat => f (btest (bits_of_Z x) i) (btest (bits_of_Z y) i))
       (ZxHpos y) (f (bsign (bits_of_Z x)) (bsign (bits_of_Z y))))
       (f (bsign (bits_of_Z x)) (bsign (bits_of_Z y)))); intro.
-    omega.
+    lia.
 Qed.
   
 Lemma Z_bitwise_ZxHbound: forall (f: bool -> bool -> bool) (x y: Z),
@@ -1035,11 +1036,11 @@ Proof.
   assert (ZxHbound x <= b) as Bx.
   { unfold b. unfold b in Rx.
     apply (ZxHpower n x).
-    omega. }
+    lia. }
   assert (ZxHbound y <= b) as By.
   { unfold b. unfold b in Ry.
     apply (ZxHpower n y).
-    omega. }
+    lia. }
   generalize (Z_bitwise_ZxHbound f x y).
   pose (zxy := Z_bitwise f x y); fold zxy.
   generalize (ZxHrange zxy).
@@ -1066,11 +1067,11 @@ Proof.
     generalize (N_recomp_pos (last (fun i : nat => f (btest (bits_of_Z x) i) (btest (bits_of_Z y) i))
       (max (bsize (bits_of_Z x)) (bsize (bits_of_Z y))) true)
       (fnot (fun i : nat => f (btest (bits_of_Z x) i) (btest (bits_of_Z y) i)))); intro; 
-    omegaContradiction.
+    liaContradiction.
   + generalize (N_recomp_pos (last (fun i : nat => f (btest (bits_of_Z x) i) (btest (bits_of_Z y) i))
       (max (bsize (bits_of_Z x)) (bsize (bits_of_Z y))) false)
       (fun i : nat => f (btest (bits_of_Z x) i) (btest (bits_of_Z y) i))); intro; 
-    omegaContradiction.
+    liaContradiction.
 Qed.
 
 Theorem Z_bitwise_is_uint: forall (f: bool -> bool -> bool) (x y: Z),  
@@ -1082,7 +1083,6 @@ Proof.
   rewrite Fsign in H1.
   replace (negb false) with true in H1 by intuition.
   case_leq 0 (Z_bitwise f x y).
-  discriminate H1.
 Qed.
 		       
 Theorem Z_bitwise_is_uint1: forall (f: bool -> bool -> bool) (x y: Z),  
@@ -1094,7 +1094,6 @@ Proof.
   rewrite (Fsign (negb (0 <=? y))) in H0.
   replace (negb false) with true in H0 by intuition.
   case_leq 0 (Z_bitwise f x y).
-  discriminate H0.
 Qed.
 		       
 Theorem Z_bitwise_is_uint2: forall (f: bool -> bool -> bool) (x y: Z),  
@@ -1106,7 +1105,6 @@ Proof.
   rewrite (Fsign (negb (0 <=? x))) in H0.
   replace (negb false) with true in H0 by intuition.
   case_leq 0 (Z_bitwise f x y).
-  discriminate H0.
 Qed.
 		    
 Theorem Z_bitwise_in_uint_range: forall (f: bool -> bool -> bool) (n: nat) (x y: Z),  
@@ -1117,14 +1115,14 @@ Proof.
   assert (ZxHbound x <= b) as Bx.
   { unfold b. unfold b in Rx.
     apply (ZxHpower n x).
-    omega. }
+    lia. }
   assert (ZxHbound y <= b) as By.
   { unfold b. unfold b in Ry.
     apply (ZxHpower n y).
-    omega. }
+    lia. }
   intro Fsign.
   assert (0 <= (Z_bitwise f x y)) as Bz.
-  { apply (Z_bitwise_is_uint f x y); auto; omega. }
+  { apply (Z_bitwise_is_uint f x y); auto; lia. }
   generalize (Z_bitwise_ZxHbound f x y).
   pose (zxy := Z_bitwise f x y); fold zxy; fold zxy in Bz.
   generalize (ZxHrange zxy).
@@ -1291,7 +1289,7 @@ Proof.
     rewrite <- (Zabs_nat_Z_of_nat k).
     apply zabs_gt. 
     rewrite <- (inj_Zabs_nat (Z_of_nat k)). rewrite Zabs_nat_Z_of_nat.
-    omega.
+    lia.
 Qed.
 					 
 Theorem Zbit_lsr: forall (x n: Z) (k: nat),
@@ -1334,7 +1332,7 @@ Proof.
   rewrite Z_decomp_recomp.
   unfold bitwise_lsr. unfold btest at 1.
   f_equal.
-  omega.
+  lia.
 Qed.
 
 
@@ -1355,13 +1353,13 @@ Proof.
   (** arg 1 *) 
   + rewrite (inj_eq_rev (k + Z.abs_nat m - Z.abs_nat n) (k + (Z.abs_nat m - Z.abs_nat n))).
     auto.
-    rewrite inj_minus1 by (apply zabs_le_plus; omega). 
+    rewrite inj_minus1 by (apply zabs_le_plus; lia). 
     repeat rewrite inj_plus. 
     rewrite inj_minus1 at 1 by (apply zabs_le; auto). 
-    omega.
+    lia.
   (** arg 2 *) 
   + apply zabs_le_plus.
-    omega.
+    lia.
 Qed.
 
 (** * ACSL bitwise operators *)
@@ -1400,17 +1398,14 @@ Proof.
   pose (bz := (bitwise andb (bits_of_Z x) (bits_of_Z y))). fold bz.
   assert ((0 <= Z_of_bits bz) <-> (bsign bz = false)).
   { rewrite Bits.bsign_encoding.
-    case_leq 0 (Z_of_bits bz); intros; split; intros; auto.
-    * omegaContradiction.
-    * discriminate H0. }
+    case_leq 0 (Z_of_bits bz); intros; split; intros; auto. }
   rewrite H.
   unfold bz. unfold bitwise. simpl.
   rewrite (bsign_encoding (bits_of_Z x)).
   rewrite bsign_encoding.
   rewrite (Z_recomp_decomp x). rewrite Z_recomp_decomp.
-  split; case_leq 0 x; intro; try omegaContradiction;
-    case_leq 0 y; intros; try omegaContradiction; auto.
-  discriminate H2.
+  split; case_leq 0 x; intro; try liaContradiction;
+    case_leq 0 y; intros; try liaContradiction; auto.
 Qed. 
 
 Theorem lor_sign: forall (x y: Z), (0 <= x /\ 0 <= y) <-> 0 <= lor x y.
@@ -1420,17 +1415,14 @@ Proof.
   pose (bz := (bitwise orb (bits_of_Z x) (bits_of_Z y))). fold bz.
   assert ((0 <= Z_of_bits bz) <-> (bsign bz = false)).
   { rewrite Bits.bsign_encoding.
-    case_leq 0 (Z_of_bits bz); intros; split; intros; auto.
-    * omegaContradiction.
-    * discriminate H0. }
+    case_leq 0 (Z_of_bits bz); intros; split; intros; auto. }
   rewrite H.
   unfold bz. unfold bitwise. simpl.
   rewrite (bsign_encoding (bits_of_Z x)).
   rewrite bsign_encoding.
   rewrite (Z_recomp_decomp x). rewrite Z_recomp_decomp.
-  split; case_leq 0 x; intro; try omegaContradiction;
-    case_leq 0 y; split; intros; try omegaContradiction;
-    discriminate H2.
+  split; case_leq 0 x; intro; try liaContradiction;
+    case_leq 0 y; split; intros; try liaContradiction.
 Qed.
 
 Theorem uint_lor_inf: forall (x y: Z), 0 <= x -> 0 <= y -> x <= lor x y.
@@ -1446,8 +1438,8 @@ Proof.
     * assert (bsign bz = false) as OPP.
       unfold bz. unfold bitwise. unfold bsign.
       unfold bits_of_Z. unfold bsign.
-      case_leq 0 x; intro; try omegaContradiction.
-      case_leq 0 y; intros; try omegaContradiction.
+      case_leq 0 x; intro; try liaContradiction.
+      case_leq 0 y; intros; try liaContradiction.
       auto.
       rewrite BSIGN in OPP. 
       discriminate.
@@ -1487,13 +1479,13 @@ Proof.
     case (lt_eq_lt_dec i k); intro cas. destruct cas.
     (** i<k *)
     * rewrite Bool.andb_false_intro2; auto.
-      apply beq_nat_false_iff; omega.
+      apply beq_nat_false_iff; lia.
     (** k=i *)
     * rewrite <- e.
       rewrite Bool.andb_false_intro1; auto.
     (** k<i *)
     * rewrite Bool.andb_false_intro2; auto.
-      apply beq_nat_false_iff; omega.
+      apply beq_nat_false_iff; lia.
 Qed.
 
 Theorem Zbit_extraction_true : 
@@ -1523,7 +1515,7 @@ Proof.
     (** i<k *)
     * rewrite Bool.andb_false_intro2; auto;
       [symmetry| ];
-      apply beq_nat_false_iff; omega.
+      apply beq_nat_false_iff; lia.
     (** k=i *)
     * rewrite <- e.
       rewrite H.
@@ -1532,7 +1524,7 @@ Proof.
     (** k<i *)
     * rewrite Bool.andb_false_intro2; auto;
       [symmetry| ];
-      apply beq_nat_false_iff; omega.
+      apply beq_nat_false_iff; lia.
 Qed.
 				 
 (** ** Properties of lnot operator *)
@@ -1547,7 +1539,7 @@ Proof.
   unfold Zbit. unfold bits_of_Z.
   pose (y := zlnot x). fold y.
   case_leq 0 x; case_leq 0 y; intros Y X; 
-    try ( unfold y in Y; unfold zlnot in Y; apply False_ind; omega); 
+    try ( unfold y in Y; unfold zlnot in Y; apply False_ind; lia); 
     simpl.
   (** Negative *)
   + unfold y. rewrite zlnot_inv. unfold fnot. trivial.
@@ -1556,8 +1548,8 @@ Proof.
 Qed.
 						   
 (** Tactical *)
-Local Ltac lnot_with_omega :=
-  repeat rewrite lnot_zlnot_equiv; unfold zlnot; omega.
+Local Ltac lnot_with_lia :=
+  repeat rewrite lnot_zlnot_equiv; unfold zlnot; lia.
     
 Theorem lnot_0: lnot 0 = -1.
 Proof.
@@ -1573,19 +1565,19 @@ Qed.
 Theorem lnot_inv: forall x: Z,
   lnot (lnot x) = x.
 Proof.
-  intros x. lnot_with_omega.
+  intros x. lnot_with_lia.
 Qed.
 					    
 Theorem lnot_sym: forall x y: Z,
   lnot x = y -> lnot y = x.
 Proof.
-  intros x y. lnot_with_omega.
+  intros x y. lnot_with_lia.
 Qed.
 
 Theorem lnot_inj: forall x y: Z,
   lnot x = lnot y -> y = x.
 Proof.
-  intros x y. lnot_with_omega.
+  intros x y. lnot_with_lia.
 Qed.
 
 (** ** Associative and commutative bitwise operators *)
@@ -1802,7 +1794,7 @@ Local Ltac lsl_distrib_r lop z :=
   intros; unfold lop; Zbit_bitwise k;
   repeat rewrite Zbit_lsl; rewrite Zbit_bitwise;
   case_leq (Z.abs z) (Z_of_nat k);
-    [ (intro; trivial) | trivial ].
+  intro; trivial.
 
 (** Distributive lsl lor *)						       
 Lemma lsl_lor_distrib_r: distributive_r lsl_def lor.
@@ -2057,7 +2049,7 @@ Theorem lnot_in_range: forall a b z: Z,
 Proof.
   intros.
   rewrite lnot_zlnot_equiv. unfold zlnot.
-  omega.
+  lia.
 Qed.		
 
 Theorem lsr_upper_bound: forall b x y: Z,
@@ -2070,7 +2062,7 @@ Proof.
   assert (PWR2: 0 < d) by apply two_power_nat_is_positive.
   apply Zdiv_lt_upper_bound; auto.
   assert (b <= b * d) by apply (upper_positive_mult_positive d b Rb PWR2).
-  omega.
+  lia.
 Qed.
 						       
 Theorem lsr_lower_bound: forall b x y: Z,
@@ -2083,7 +2075,7 @@ Proof.
   assert (PWR2: 0 < d) by apply two_power_nat_is_positive.
   apply Zdiv_le_lower_bound; auto.
   assert (b * d <= b) by apply (lower_negative_mult_positive d b Rb PWR2).
-  omega.
+  lia.
 Qed.						       				
 	
 (** * Other properties of bitwise operators *)
@@ -2138,14 +2130,14 @@ Proof.
   unfold land; rewrite Zbit_bitwise.
   rewrite Zbit_power_minus_one.
   nat_compare Inf EQ Sup n k.
-  + rewrite (leb_correct n k) by omega.
-    rewrite (leb_correct_conv n (S k)) by omega. 
+  + rewrite (leb_correct n k) by lia.
+    rewrite (leb_correct_conv n (S k)) by lia. 
     simpl; auto.
-  + rewrite (leb_correct n n) by omega.
-    rewrite (leb_correct_conv n (S n)) by omega. 
+  + rewrite (leb_correct n n) by lia.
+    rewrite (leb_correct_conv n (S n)) by lia. 
     simpl; auto.
-  + rewrite (leb_correct_conv k n) by omega.
-    rewrite (leb_correct (S k) n) by omega.
+  + rewrite (leb_correct_conv k n) by lia.
+    rewrite (leb_correct (S k) n) by lia.
     simpl; auto.  
 Qed.
 			    
